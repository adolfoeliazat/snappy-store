/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "snappydata_struct_ServiceMetaData.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace io { namespace snappydata { namespace thrift {


ServiceMetaData::~ServiceMetaData() noexcept {
}


void ServiceMetaData::__set_productName(const std::string& val) {
  this->productName = val;
}

void ServiceMetaData::__set_productVersion(const std::string& val) {
  this->productVersion = val;
}

void ServiceMetaData::__set_productMajorVersion(const int32_t val) {
  this->productMajorVersion = val;
}

void ServiceMetaData::__set_productMinorVersion(const int32_t val) {
  this->productMinorVersion = val;
}

void ServiceMetaData::__set_jdbcMajorVersion(const int32_t val) {
  this->jdbcMajorVersion = val;
}

void ServiceMetaData::__set_jdbcMinorVersion(const int32_t val) {
  this->jdbcMinorVersion = val;
}

void ServiceMetaData::__set_identifierQuote(const std::string& val) {
  this->identifierQuote = val;
}

void ServiceMetaData::__set_sqlKeywords(const std::vector<std::string> & val) {
  this->sqlKeywords = val;
}

void ServiceMetaData::__set_numericFunctions(const std::vector<std::string> & val) {
  this->numericFunctions = val;
}

void ServiceMetaData::__set_stringFunctions(const std::vector<std::string> & val) {
  this->stringFunctions = val;
}

void ServiceMetaData::__set_systemFunctions(const std::vector<std::string> & val) {
  this->systemFunctions = val;
}

void ServiceMetaData::__set_dateTimeFunctions(const std::vector<std::string> & val) {
  this->dateTimeFunctions = val;
}

void ServiceMetaData::__set_searchStringEscape(const std::string& val) {
  this->searchStringEscape = val;
}

void ServiceMetaData::__set_extraNameCharacters(const std::string& val) {
  this->extraNameCharacters = val;
__isset.extraNameCharacters = true;
}

void ServiceMetaData::__set_supportedCONVERT(const std::map<SnappyType::type, std::set<SnappyType::type> > & val) {
  this->supportedCONVERT = val;
}

void ServiceMetaData::__set_schemaTerm(const std::string& val) {
  this->schemaTerm = val;
}

void ServiceMetaData::__set_procedureTerm(const std::string& val) {
  this->procedureTerm = val;
}

void ServiceMetaData::__set_catalogTerm(const std::string& val) {
  this->catalogTerm = val;
}

void ServiceMetaData::__set_catalogSeparator(const std::string& val) {
  this->catalogSeparator = val;
}

void ServiceMetaData::__set_maxBinaryLiteralLength(const int32_t val) {
  this->maxBinaryLiteralLength = val;
}

void ServiceMetaData::__set_maxCharLiteralLength(const int32_t val) {
  this->maxCharLiteralLength = val;
}

void ServiceMetaData::__set_maxColumnsInGroupBy(const int32_t val) {
  this->maxColumnsInGroupBy = val;
}

void ServiceMetaData::__set_maxColumnsInIndex(const int32_t val) {
  this->maxColumnsInIndex = val;
}

void ServiceMetaData::__set_maxColumnsInOrderBy(const int32_t val) {
  this->maxColumnsInOrderBy = val;
}

void ServiceMetaData::__set_maxColumnsInSelect(const int32_t val) {
  this->maxColumnsInSelect = val;
}

void ServiceMetaData::__set_maxColumnsInTable(const int32_t val) {
  this->maxColumnsInTable = val;
}

void ServiceMetaData::__set_maxConnections(const int32_t val) {
  this->maxConnections = val;
}

void ServiceMetaData::__set_maxIndexLength(const int32_t val) {
  this->maxIndexLength = val;
}

void ServiceMetaData::__set_maxRowSize(const int32_t val) {
  this->maxRowSize = val;
}

void ServiceMetaData::__set_maxStatementLength(const int32_t val) {
  this->maxStatementLength = val;
}

void ServiceMetaData::__set_maxOpenStatements(const int32_t val) {
  this->maxOpenStatements = val;
}

void ServiceMetaData::__set_maxTableNamesInSelect(const int32_t val) {
  this->maxTableNamesInSelect = val;
}

void ServiceMetaData::__set_maxColumnNameLength(const int32_t val) {
  this->maxColumnNameLength = val;
}

void ServiceMetaData::__set_maxCursorNameLength(const int32_t val) {
  this->maxCursorNameLength = val;
}

void ServiceMetaData::__set_maxSchemaNameLength(const int32_t val) {
  this->maxSchemaNameLength = val;
}

void ServiceMetaData::__set_maxProcedureNameLength(const int32_t val) {
  this->maxProcedureNameLength = val;
}

void ServiceMetaData::__set_maxCatalogNameLength(const int32_t val) {
  this->maxCatalogNameLength = val;
}

void ServiceMetaData::__set_maxTableNameLength(const int32_t val) {
  this->maxTableNameLength = val;
}

void ServiceMetaData::__set_maxUserNameLength(const int32_t val) {
  this->maxUserNameLength = val;
}

void ServiceMetaData::__set_defaultTransactionIsolation(const int32_t val) {
  this->defaultTransactionIsolation = val;
}

void ServiceMetaData::__set_defaultResultSetType(const int8_t val) {
  this->defaultResultSetType = val;
}

void ServiceMetaData::__set_defaultResultSetHoldabilityHoldCursorsOverCommit(const bool val) {
  this->defaultResultSetHoldabilityHoldCursorsOverCommit = val;
}

void ServiceMetaData::__set_sqlStateIsXOpen(const bool val) {
  this->sqlStateIsXOpen = val;
}

void ServiceMetaData::__set_catalogAtStart(const bool val) {
  this->catalogAtStart = val;
}

void ServiceMetaData::__set_transactionDefaults(const std::map<TransactionAttribute::type, bool> & val) {
  this->transactionDefaults = val;
}

void ServiceMetaData::__set_rowIdLifeTime(const RowIdLifetime::type val) {
  this->rowIdLifeTime = val;
}

void ServiceMetaData::__set_supportedFeatures(const std::set<ServiceFeature::type> & val) {
  this->supportedFeatures = val;
}

void ServiceMetaData::__set_featuresWithParams(const std::map<ServiceFeatureParameterized::type, std::vector<int32_t> > & val) {
  this->featuresWithParams = val;
}

uint32_t ServiceMetaData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_productName = false;
  bool isset_productVersion = false;
  bool isset_productMajorVersion = false;
  bool isset_productMinorVersion = false;
  bool isset_jdbcMajorVersion = false;
  bool isset_jdbcMinorVersion = false;
  bool isset_identifierQuote = false;
  bool isset_sqlKeywords = false;
  bool isset_numericFunctions = false;
  bool isset_stringFunctions = false;
  bool isset_systemFunctions = false;
  bool isset_dateTimeFunctions = false;
  bool isset_searchStringEscape = false;
  bool isset_supportedCONVERT = false;
  bool isset_schemaTerm = false;
  bool isset_procedureTerm = false;
  bool isset_catalogTerm = false;
  bool isset_catalogSeparator = false;
  bool isset_maxBinaryLiteralLength = false;
  bool isset_maxCharLiteralLength = false;
  bool isset_maxColumnsInGroupBy = false;
  bool isset_maxColumnsInIndex = false;
  bool isset_maxColumnsInOrderBy = false;
  bool isset_maxColumnsInSelect = false;
  bool isset_maxColumnsInTable = false;
  bool isset_maxConnections = false;
  bool isset_maxIndexLength = false;
  bool isset_maxRowSize = false;
  bool isset_maxStatementLength = false;
  bool isset_maxOpenStatements = false;
  bool isset_maxTableNamesInSelect = false;
  bool isset_maxColumnNameLength = false;
  bool isset_maxCursorNameLength = false;
  bool isset_maxSchemaNameLength = false;
  bool isset_maxProcedureNameLength = false;
  bool isset_maxCatalogNameLength = false;
  bool isset_maxTableNameLength = false;
  bool isset_maxUserNameLength = false;
  bool isset_defaultTransactionIsolation = false;
  bool isset_defaultResultSetType = false;
  bool isset_defaultResultSetHoldabilityHoldCursorsOverCommit = false;
  bool isset_sqlStateIsXOpen = false;
  bool isset_catalogAtStart = false;
  bool isset_transactionDefaults = false;
  bool isset_rowIdLifeTime = false;
  bool isset_supportedFeatures = false;
  bool isset_featuresWithParams = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->productName);
          isset_productName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->productVersion);
          isset_productVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->productMajorVersion);
          isset_productMajorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->productMinorVersion);
          isset_productMinorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->jdbcMajorVersion);
          isset_jdbcMajorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->jdbcMinorVersion);
          isset_jdbcMinorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->identifierQuote);
          isset_identifierQuote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sqlKeywords.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->sqlKeywords.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += iprot->readString(this->sqlKeywords[_i56]);
            }
            xfer += iprot->readListEnd();
          }
          isset_sqlKeywords = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->numericFunctions.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->numericFunctions.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += iprot->readString(this->numericFunctions[_i61]);
            }
            xfer += iprot->readListEnd();
          }
          isset_numericFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stringFunctions.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->stringFunctions.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += iprot->readString(this->stringFunctions[_i66]);
            }
            xfer += iprot->readListEnd();
          }
          isset_stringFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->systemFunctions.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->systemFunctions.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += iprot->readString(this->systemFunctions[_i71]);
            }
            xfer += iprot->readListEnd();
          }
          isset_systemFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dateTimeFunctions.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->dateTimeFunctions.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += iprot->readString(this->dateTimeFunctions[_i76]);
            }
            xfer += iprot->readListEnd();
          }
          isset_dateTimeFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->searchStringEscape);
          isset_searchStringEscape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->extraNameCharacters);
          this->__isset.extraNameCharacters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->supportedCONVERT.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _ktype78;
            ::apache::thrift::protocol::TType _vtype79;
            xfer += iprot->readMapBegin(_ktype78, _vtype79, _size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              SnappyType::type _key82;
              int32_t ecast84;
              xfer += iprot->readI32(ecast84);
              _key82 = (SnappyType::type)ecast84;
              std::set<SnappyType::type> & _val83 = this->supportedCONVERT[_key82];
              {
                _val83.clear();
                uint32_t _size85;
                ::apache::thrift::protocol::TType _etype88;
                xfer += iprot->readSetBegin(_etype88, _size85);
                uint32_t _i89;
                for (_i89 = 0; _i89 < _size85; ++_i89)
                {
                  SnappyType::type _elem90;
                  int32_t ecast91;
                  xfer += iprot->readI32(ecast91);
                  _elem90 = (SnappyType::type)ecast91;
                  _val83.insert(_elem90);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_supportedCONVERT = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaTerm);
          isset_schemaTerm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->procedureTerm);
          isset_procedureTerm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogTerm);
          isset_catalogTerm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogSeparator);
          isset_catalogSeparator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxBinaryLiteralLength);
          isset_maxBinaryLiteralLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCharLiteralLength);
          isset_maxCharLiteralLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInGroupBy);
          isset_maxColumnsInGroupBy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInIndex);
          isset_maxColumnsInIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInOrderBy);
          isset_maxColumnsInOrderBy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInSelect);
          isset_maxColumnsInSelect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInTable);
          isset_maxColumnsInTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxConnections);
          isset_maxConnections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxIndexLength);
          isset_maxIndexLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxRowSize);
          isset_maxRowSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxStatementLength);
          isset_maxStatementLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxOpenStatements);
          isset_maxOpenStatements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxTableNamesInSelect);
          isset_maxTableNamesInSelect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnNameLength);
          isset_maxColumnNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCursorNameLength);
          isset_maxCursorNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxSchemaNameLength);
          isset_maxSchemaNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxProcedureNameLength);
          isset_maxProcedureNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 37:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCatalogNameLength);
          isset_maxCatalogNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 38:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxTableNameLength);
          isset_maxTableNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 39:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxUserNameLength);
          isset_maxUserNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->defaultTransactionIsolation);
          isset_defaultTransactionIsolation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->defaultResultSetType);
          isset_defaultResultSetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 42:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->defaultResultSetHoldabilityHoldCursorsOverCommit);
          isset_defaultResultSetHoldabilityHoldCursorsOverCommit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 43:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sqlStateIsXOpen);
          isset_sqlStateIsXOpen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 44:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->catalogAtStart);
          isset_catalogAtStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 45:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->transactionDefaults.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _ktype93;
            ::apache::thrift::protocol::TType _vtype94;
            xfer += iprot->readMapBegin(_ktype93, _vtype94, _size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              TransactionAttribute::type _key97;
              int32_t ecast99;
              xfer += iprot->readI32(ecast99);
              _key97 = (TransactionAttribute::type)ecast99;
              bool& _val98 = this->transactionDefaults[_key97];
              xfer += iprot->readBool(_val98);
            }
            xfer += iprot->readMapEnd();
          }
          isset_transactionDefaults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 46:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast100;
          xfer += iprot->readI32(ecast100);
          this->rowIdLifeTime = (RowIdLifetime::type)ecast100;
          isset_rowIdLifeTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 47:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->supportedFeatures.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _etype104;
            xfer += iprot->readSetBegin(_etype104, _size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              ServiceFeature::type _elem106;
              int32_t ecast107;
              xfer += iprot->readI32(ecast107);
              _elem106 = (ServiceFeature::type)ecast107;
              this->supportedFeatures.insert(_elem106);
            }
            xfer += iprot->readSetEnd();
          }
          isset_supportedFeatures = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 48:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->featuresWithParams.clear();
            uint32_t _size108;
            ::apache::thrift::protocol::TType _ktype109;
            ::apache::thrift::protocol::TType _vtype110;
            xfer += iprot->readMapBegin(_ktype109, _vtype110, _size108);
            uint32_t _i112;
            for (_i112 = 0; _i112 < _size108; ++_i112)
            {
              ServiceFeatureParameterized::type _key113;
              int32_t ecast115;
              xfer += iprot->readI32(ecast115);
              _key113 = (ServiceFeatureParameterized::type)ecast115;
              std::vector<int32_t> & _val114 = this->featuresWithParams[_key113];
              {
                _val114.clear();
                uint32_t _size116;
                ::apache::thrift::protocol::TType _etype119;
                xfer += iprot->readListBegin(_etype119, _size116);
                _val114.resize(_size116);
                uint32_t _i120;
                for (_i120 = 0; _i120 < _size116; ++_i120)
                {
                  xfer += iprot->readI32(_val114[_i120]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_featuresWithParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_productName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_productVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_productMajorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_productMinorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_jdbcMajorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_jdbcMinorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_identifierQuote)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sqlKeywords)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numericFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_stringFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_systemFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dateTimeFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_searchStringEscape)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_supportedCONVERT)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schemaTerm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_procedureTerm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalogTerm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalogSeparator)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxBinaryLiteralLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxCharLiteralLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInGroupBy)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInIndex)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInOrderBy)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInSelect)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInTable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxConnections)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxIndexLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxRowSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxStatementLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxOpenStatements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxTableNamesInSelect)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxCursorNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxSchemaNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxProcedureNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxCatalogNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxTableNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxUserNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultTransactionIsolation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultResultSetType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultResultSetHoldabilityHoldCursorsOverCommit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sqlStateIsXOpen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalogAtStart)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_transactionDefaults)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rowIdLifeTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_supportedFeatures)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_featuresWithParams)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServiceMetaData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServiceMetaData");

  xfer += oprot->writeFieldBegin("productName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->productName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productVersion", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->productVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productMajorVersion", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->productMajorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productMinorVersion", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->productMinorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jdbcMajorVersion", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->jdbcMajorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jdbcMinorVersion", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->jdbcMinorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("identifierQuote", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->identifierQuote);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqlKeywords", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sqlKeywords.size()));
    std::vector<std::string> ::const_iterator _iter121;
    for (_iter121 = this->sqlKeywords.begin(); _iter121 != this->sqlKeywords.end(); ++_iter121)
    {
      xfer += oprot->writeString((*_iter121));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numericFunctions", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->numericFunctions.size()));
    std::vector<std::string> ::const_iterator _iter122;
    for (_iter122 = this->numericFunctions.begin(); _iter122 != this->numericFunctions.end(); ++_iter122)
    {
      xfer += oprot->writeString((*_iter122));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringFunctions", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->stringFunctions.size()));
    std::vector<std::string> ::const_iterator _iter123;
    for (_iter123 = this->stringFunctions.begin(); _iter123 != this->stringFunctions.end(); ++_iter123)
    {
      xfer += oprot->writeString((*_iter123));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("systemFunctions", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->systemFunctions.size()));
    std::vector<std::string> ::const_iterator _iter124;
    for (_iter124 = this->systemFunctions.begin(); _iter124 != this->systemFunctions.end(); ++_iter124)
    {
      xfer += oprot->writeString((*_iter124));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dateTimeFunctions", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dateTimeFunctions.size()));
    std::vector<std::string> ::const_iterator _iter125;
    for (_iter125 = this->dateTimeFunctions.begin(); _iter125 != this->dateTimeFunctions.end(); ++_iter125)
    {
      xfer += oprot->writeString((*_iter125));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("searchStringEscape", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->searchStringEscape);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.extraNameCharacters) {
    xfer += oprot->writeFieldBegin("extraNameCharacters", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->extraNameCharacters);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("supportedCONVERT", ::apache::thrift::protocol::T_MAP, 15);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->supportedCONVERT.size()));
    std::map<SnappyType::type, std::set<SnappyType::type> > ::const_iterator _iter126;
    for (_iter126 = this->supportedCONVERT.begin(); _iter126 != this->supportedCONVERT.end(); ++_iter126)
    {
      xfer += oprot->writeI32((int32_t)_iter126->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter126->second.size()));
        std::set<SnappyType::type> ::const_iterator _iter127;
        for (_iter127 = _iter126->second.begin(); _iter127 != _iter126->second.end(); ++_iter127)
        {
          xfer += oprot->writeI32((int32_t)(*_iter127));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schemaTerm", ::apache::thrift::protocol::T_STRING, 16);
  xfer += oprot->writeString(this->schemaTerm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("procedureTerm", ::apache::thrift::protocol::T_STRING, 17);
  xfer += oprot->writeString(this->procedureTerm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catalogTerm", ::apache::thrift::protocol::T_STRING, 18);
  xfer += oprot->writeString(this->catalogTerm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catalogSeparator", ::apache::thrift::protocol::T_STRING, 19);
  xfer += oprot->writeString(this->catalogSeparator);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxBinaryLiteralLength", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->maxBinaryLiteralLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCharLiteralLength", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->maxCharLiteralLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInGroupBy", ::apache::thrift::protocol::T_I32, 22);
  xfer += oprot->writeI32(this->maxColumnsInGroupBy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInIndex", ::apache::thrift::protocol::T_I32, 23);
  xfer += oprot->writeI32(this->maxColumnsInIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInOrderBy", ::apache::thrift::protocol::T_I32, 24);
  xfer += oprot->writeI32(this->maxColumnsInOrderBy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInSelect", ::apache::thrift::protocol::T_I32, 25);
  xfer += oprot->writeI32(this->maxColumnsInSelect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInTable", ::apache::thrift::protocol::T_I32, 26);
  xfer += oprot->writeI32(this->maxColumnsInTable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxConnections", ::apache::thrift::protocol::T_I32, 27);
  xfer += oprot->writeI32(this->maxConnections);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxIndexLength", ::apache::thrift::protocol::T_I32, 28);
  xfer += oprot->writeI32(this->maxIndexLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxRowSize", ::apache::thrift::protocol::T_I32, 29);
  xfer += oprot->writeI32(this->maxRowSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxStatementLength", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->maxStatementLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxOpenStatements", ::apache::thrift::protocol::T_I32, 31);
  xfer += oprot->writeI32(this->maxOpenStatements);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxTableNamesInSelect", ::apache::thrift::protocol::T_I32, 32);
  xfer += oprot->writeI32(this->maxTableNamesInSelect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnNameLength", ::apache::thrift::protocol::T_I32, 33);
  xfer += oprot->writeI32(this->maxColumnNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCursorNameLength", ::apache::thrift::protocol::T_I32, 34);
  xfer += oprot->writeI32(this->maxCursorNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxSchemaNameLength", ::apache::thrift::protocol::T_I32, 35);
  xfer += oprot->writeI32(this->maxSchemaNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxProcedureNameLength", ::apache::thrift::protocol::T_I32, 36);
  xfer += oprot->writeI32(this->maxProcedureNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCatalogNameLength", ::apache::thrift::protocol::T_I32, 37);
  xfer += oprot->writeI32(this->maxCatalogNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxTableNameLength", ::apache::thrift::protocol::T_I32, 38);
  xfer += oprot->writeI32(this->maxTableNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxUserNameLength", ::apache::thrift::protocol::T_I32, 39);
  xfer += oprot->writeI32(this->maxUserNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultTransactionIsolation", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->defaultTransactionIsolation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultResultSetType", ::apache::thrift::protocol::T_BYTE, 41);
  xfer += oprot->writeByte(this->defaultResultSetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultResultSetHoldabilityHoldCursorsOverCommit", ::apache::thrift::protocol::T_BOOL, 42);
  xfer += oprot->writeBool(this->defaultResultSetHoldabilityHoldCursorsOverCommit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqlStateIsXOpen", ::apache::thrift::protocol::T_BOOL, 43);
  xfer += oprot->writeBool(this->sqlStateIsXOpen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catalogAtStart", ::apache::thrift::protocol::T_BOOL, 44);
  xfer += oprot->writeBool(this->catalogAtStart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionDefaults", ::apache::thrift::protocol::T_MAP, 45);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->transactionDefaults.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter128;
    for (_iter128 = this->transactionDefaults.begin(); _iter128 != this->transactionDefaults.end(); ++_iter128)
    {
      xfer += oprot->writeI32((int32_t)_iter128->first);
      xfer += oprot->writeBool(_iter128->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rowIdLifeTime", ::apache::thrift::protocol::T_I32, 46);
  xfer += oprot->writeI32((int32_t)this->rowIdLifeTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("supportedFeatures", ::apache::thrift::protocol::T_SET, 47);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->supportedFeatures.size()));
    std::set<ServiceFeature::type> ::const_iterator _iter129;
    for (_iter129 = this->supportedFeatures.begin(); _iter129 != this->supportedFeatures.end(); ++_iter129)
    {
      xfer += oprot->writeI32((int32_t)(*_iter129));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("featuresWithParams", ::apache::thrift::protocol::T_MAP, 48);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->featuresWithParams.size()));
    std::map<ServiceFeatureParameterized::type, std::vector<int32_t> > ::const_iterator _iter130;
    for (_iter130 = this->featuresWithParams.begin(); _iter130 != this->featuresWithParams.end(); ++_iter130)
    {
      xfer += oprot->writeI32((int32_t)_iter130->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter130->second.size()));
        std::vector<int32_t> ::const_iterator _iter131;
        for (_iter131 = _iter130->second.begin(); _iter131 != _iter130->second.end(); ++_iter131)
        {
          xfer += oprot->writeI32((*_iter131));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServiceMetaData &a, ServiceMetaData &b) noexcept {
  using ::std::swap;
  static_assert(noexcept(swap(a, b)), "throwing swap");
  swap(a.productName, b.productName);
  swap(a.productVersion, b.productVersion);
  swap(a.productMajorVersion, b.productMajorVersion);
  swap(a.productMinorVersion, b.productMinorVersion);
  swap(a.jdbcMajorVersion, b.jdbcMajorVersion);
  swap(a.jdbcMinorVersion, b.jdbcMinorVersion);
  swap(a.identifierQuote, b.identifierQuote);
  swap(a.sqlKeywords, b.sqlKeywords);
  swap(a.numericFunctions, b.numericFunctions);
  swap(a.stringFunctions, b.stringFunctions);
  swap(a.systemFunctions, b.systemFunctions);
  swap(a.dateTimeFunctions, b.dateTimeFunctions);
  swap(a.searchStringEscape, b.searchStringEscape);
  swap(a.extraNameCharacters, b.extraNameCharacters);
  swap(a.supportedCONVERT, b.supportedCONVERT);
  swap(a.schemaTerm, b.schemaTerm);
  swap(a.procedureTerm, b.procedureTerm);
  swap(a.catalogTerm, b.catalogTerm);
  swap(a.catalogSeparator, b.catalogSeparator);
  swap(a.maxBinaryLiteralLength, b.maxBinaryLiteralLength);
  swap(a.maxCharLiteralLength, b.maxCharLiteralLength);
  swap(a.maxColumnsInGroupBy, b.maxColumnsInGroupBy);
  swap(a.maxColumnsInIndex, b.maxColumnsInIndex);
  swap(a.maxColumnsInOrderBy, b.maxColumnsInOrderBy);
  swap(a.maxColumnsInSelect, b.maxColumnsInSelect);
  swap(a.maxColumnsInTable, b.maxColumnsInTable);
  swap(a.maxConnections, b.maxConnections);
  swap(a.maxIndexLength, b.maxIndexLength);
  swap(a.maxRowSize, b.maxRowSize);
  swap(a.maxStatementLength, b.maxStatementLength);
  swap(a.maxOpenStatements, b.maxOpenStatements);
  swap(a.maxTableNamesInSelect, b.maxTableNamesInSelect);
  swap(a.maxColumnNameLength, b.maxColumnNameLength);
  swap(a.maxCursorNameLength, b.maxCursorNameLength);
  swap(a.maxSchemaNameLength, b.maxSchemaNameLength);
  swap(a.maxProcedureNameLength, b.maxProcedureNameLength);
  swap(a.maxCatalogNameLength, b.maxCatalogNameLength);
  swap(a.maxTableNameLength, b.maxTableNameLength);
  swap(a.maxUserNameLength, b.maxUserNameLength);
  swap(a.defaultTransactionIsolation, b.defaultTransactionIsolation);
  swap(a.defaultResultSetType, b.defaultResultSetType);
  swap(a.defaultResultSetHoldabilityHoldCursorsOverCommit, b.defaultResultSetHoldabilityHoldCursorsOverCommit);
  swap(a.sqlStateIsXOpen, b.sqlStateIsXOpen);
  swap(a.catalogAtStart, b.catalogAtStart);
  swap(a.transactionDefaults, b.transactionDefaults);
  swap(a.rowIdLifeTime, b.rowIdLifeTime);
  swap(a.supportedFeatures, b.supportedFeatures);
  swap(a.featuresWithParams, b.featuresWithParams);
  swap(a.__isset, b.__isset);
}

ServiceMetaData::ServiceMetaData(const ServiceMetaData& other132) {
  productName = other132.productName;
  productVersion = other132.productVersion;
  productMajorVersion = other132.productMajorVersion;
  productMinorVersion = other132.productMinorVersion;
  jdbcMajorVersion = other132.jdbcMajorVersion;
  jdbcMinorVersion = other132.jdbcMinorVersion;
  identifierQuote = other132.identifierQuote;
  sqlKeywords = other132.sqlKeywords;
  numericFunctions = other132.numericFunctions;
  stringFunctions = other132.stringFunctions;
  systemFunctions = other132.systemFunctions;
  dateTimeFunctions = other132.dateTimeFunctions;
  searchStringEscape = other132.searchStringEscape;
  extraNameCharacters = other132.extraNameCharacters;
  supportedCONVERT = other132.supportedCONVERT;
  schemaTerm = other132.schemaTerm;
  procedureTerm = other132.procedureTerm;
  catalogTerm = other132.catalogTerm;
  catalogSeparator = other132.catalogSeparator;
  maxBinaryLiteralLength = other132.maxBinaryLiteralLength;
  maxCharLiteralLength = other132.maxCharLiteralLength;
  maxColumnsInGroupBy = other132.maxColumnsInGroupBy;
  maxColumnsInIndex = other132.maxColumnsInIndex;
  maxColumnsInOrderBy = other132.maxColumnsInOrderBy;
  maxColumnsInSelect = other132.maxColumnsInSelect;
  maxColumnsInTable = other132.maxColumnsInTable;
  maxConnections = other132.maxConnections;
  maxIndexLength = other132.maxIndexLength;
  maxRowSize = other132.maxRowSize;
  maxStatementLength = other132.maxStatementLength;
  maxOpenStatements = other132.maxOpenStatements;
  maxTableNamesInSelect = other132.maxTableNamesInSelect;
  maxColumnNameLength = other132.maxColumnNameLength;
  maxCursorNameLength = other132.maxCursorNameLength;
  maxSchemaNameLength = other132.maxSchemaNameLength;
  maxProcedureNameLength = other132.maxProcedureNameLength;
  maxCatalogNameLength = other132.maxCatalogNameLength;
  maxTableNameLength = other132.maxTableNameLength;
  maxUserNameLength = other132.maxUserNameLength;
  defaultTransactionIsolation = other132.defaultTransactionIsolation;
  defaultResultSetType = other132.defaultResultSetType;
  defaultResultSetHoldabilityHoldCursorsOverCommit = other132.defaultResultSetHoldabilityHoldCursorsOverCommit;
  sqlStateIsXOpen = other132.sqlStateIsXOpen;
  catalogAtStart = other132.catalogAtStart;
  transactionDefaults = other132.transactionDefaults;
  rowIdLifeTime = other132.rowIdLifeTime;
  supportedFeatures = other132.supportedFeatures;
  featuresWithParams = other132.featuresWithParams;
  __isset = other132.__isset;
}
ServiceMetaData::ServiceMetaData( ServiceMetaData&& other133) noexcept {
  productName = std::move(other133.productName);
  productVersion = std::move(other133.productVersion);
  productMajorVersion = std::move(other133.productMajorVersion);
  productMinorVersion = std::move(other133.productMinorVersion);
  jdbcMajorVersion = std::move(other133.jdbcMajorVersion);
  jdbcMinorVersion = std::move(other133.jdbcMinorVersion);
  identifierQuote = std::move(other133.identifierQuote);
  sqlKeywords = std::move(other133.sqlKeywords);
  numericFunctions = std::move(other133.numericFunctions);
  stringFunctions = std::move(other133.stringFunctions);
  systemFunctions = std::move(other133.systemFunctions);
  dateTimeFunctions = std::move(other133.dateTimeFunctions);
  searchStringEscape = std::move(other133.searchStringEscape);
  extraNameCharacters = std::move(other133.extraNameCharacters);
  supportedCONVERT = std::move(other133.supportedCONVERT);
  schemaTerm = std::move(other133.schemaTerm);
  procedureTerm = std::move(other133.procedureTerm);
  catalogTerm = std::move(other133.catalogTerm);
  catalogSeparator = std::move(other133.catalogSeparator);
  maxBinaryLiteralLength = std::move(other133.maxBinaryLiteralLength);
  maxCharLiteralLength = std::move(other133.maxCharLiteralLength);
  maxColumnsInGroupBy = std::move(other133.maxColumnsInGroupBy);
  maxColumnsInIndex = std::move(other133.maxColumnsInIndex);
  maxColumnsInOrderBy = std::move(other133.maxColumnsInOrderBy);
  maxColumnsInSelect = std::move(other133.maxColumnsInSelect);
  maxColumnsInTable = std::move(other133.maxColumnsInTable);
  maxConnections = std::move(other133.maxConnections);
  maxIndexLength = std::move(other133.maxIndexLength);
  maxRowSize = std::move(other133.maxRowSize);
  maxStatementLength = std::move(other133.maxStatementLength);
  maxOpenStatements = std::move(other133.maxOpenStatements);
  maxTableNamesInSelect = std::move(other133.maxTableNamesInSelect);
  maxColumnNameLength = std::move(other133.maxColumnNameLength);
  maxCursorNameLength = std::move(other133.maxCursorNameLength);
  maxSchemaNameLength = std::move(other133.maxSchemaNameLength);
  maxProcedureNameLength = std::move(other133.maxProcedureNameLength);
  maxCatalogNameLength = std::move(other133.maxCatalogNameLength);
  maxTableNameLength = std::move(other133.maxTableNameLength);
  maxUserNameLength = std::move(other133.maxUserNameLength);
  defaultTransactionIsolation = std::move(other133.defaultTransactionIsolation);
  defaultResultSetType = std::move(other133.defaultResultSetType);
  defaultResultSetHoldabilityHoldCursorsOverCommit = std::move(other133.defaultResultSetHoldabilityHoldCursorsOverCommit);
  sqlStateIsXOpen = std::move(other133.sqlStateIsXOpen);
  catalogAtStart = std::move(other133.catalogAtStart);
  transactionDefaults = std::move(other133.transactionDefaults);
  rowIdLifeTime = std::move(other133.rowIdLifeTime);
  supportedFeatures = std::move(other133.supportedFeatures);
  featuresWithParams = std::move(other133.featuresWithParams);
  __isset = std::move(other133.__isset);
}
ServiceMetaData& ServiceMetaData::operator=(const ServiceMetaData& other134) {
  productName = other134.productName;
  productVersion = other134.productVersion;
  productMajorVersion = other134.productMajorVersion;
  productMinorVersion = other134.productMinorVersion;
  jdbcMajorVersion = other134.jdbcMajorVersion;
  jdbcMinorVersion = other134.jdbcMinorVersion;
  identifierQuote = other134.identifierQuote;
  sqlKeywords = other134.sqlKeywords;
  numericFunctions = other134.numericFunctions;
  stringFunctions = other134.stringFunctions;
  systemFunctions = other134.systemFunctions;
  dateTimeFunctions = other134.dateTimeFunctions;
  searchStringEscape = other134.searchStringEscape;
  extraNameCharacters = other134.extraNameCharacters;
  supportedCONVERT = other134.supportedCONVERT;
  schemaTerm = other134.schemaTerm;
  procedureTerm = other134.procedureTerm;
  catalogTerm = other134.catalogTerm;
  catalogSeparator = other134.catalogSeparator;
  maxBinaryLiteralLength = other134.maxBinaryLiteralLength;
  maxCharLiteralLength = other134.maxCharLiteralLength;
  maxColumnsInGroupBy = other134.maxColumnsInGroupBy;
  maxColumnsInIndex = other134.maxColumnsInIndex;
  maxColumnsInOrderBy = other134.maxColumnsInOrderBy;
  maxColumnsInSelect = other134.maxColumnsInSelect;
  maxColumnsInTable = other134.maxColumnsInTable;
  maxConnections = other134.maxConnections;
  maxIndexLength = other134.maxIndexLength;
  maxRowSize = other134.maxRowSize;
  maxStatementLength = other134.maxStatementLength;
  maxOpenStatements = other134.maxOpenStatements;
  maxTableNamesInSelect = other134.maxTableNamesInSelect;
  maxColumnNameLength = other134.maxColumnNameLength;
  maxCursorNameLength = other134.maxCursorNameLength;
  maxSchemaNameLength = other134.maxSchemaNameLength;
  maxProcedureNameLength = other134.maxProcedureNameLength;
  maxCatalogNameLength = other134.maxCatalogNameLength;
  maxTableNameLength = other134.maxTableNameLength;
  maxUserNameLength = other134.maxUserNameLength;
  defaultTransactionIsolation = other134.defaultTransactionIsolation;
  defaultResultSetType = other134.defaultResultSetType;
  defaultResultSetHoldabilityHoldCursorsOverCommit = other134.defaultResultSetHoldabilityHoldCursorsOverCommit;
  sqlStateIsXOpen = other134.sqlStateIsXOpen;
  catalogAtStart = other134.catalogAtStart;
  transactionDefaults = other134.transactionDefaults;
  rowIdLifeTime = other134.rowIdLifeTime;
  supportedFeatures = other134.supportedFeatures;
  featuresWithParams = other134.featuresWithParams;
  __isset = other134.__isset;
  return *this;
}
ServiceMetaData& ServiceMetaData::operator=(ServiceMetaData&& other135) noexcept {
  productName = std::move(other135.productName);
  productVersion = std::move(other135.productVersion);
  productMajorVersion = std::move(other135.productMajorVersion);
  productMinorVersion = std::move(other135.productMinorVersion);
  jdbcMajorVersion = std::move(other135.jdbcMajorVersion);
  jdbcMinorVersion = std::move(other135.jdbcMinorVersion);
  identifierQuote = std::move(other135.identifierQuote);
  sqlKeywords = std::move(other135.sqlKeywords);
  numericFunctions = std::move(other135.numericFunctions);
  stringFunctions = std::move(other135.stringFunctions);
  systemFunctions = std::move(other135.systemFunctions);
  dateTimeFunctions = std::move(other135.dateTimeFunctions);
  searchStringEscape = std::move(other135.searchStringEscape);
  extraNameCharacters = std::move(other135.extraNameCharacters);
  supportedCONVERT = std::move(other135.supportedCONVERT);
  schemaTerm = std::move(other135.schemaTerm);
  procedureTerm = std::move(other135.procedureTerm);
  catalogTerm = std::move(other135.catalogTerm);
  catalogSeparator = std::move(other135.catalogSeparator);
  maxBinaryLiteralLength = std::move(other135.maxBinaryLiteralLength);
  maxCharLiteralLength = std::move(other135.maxCharLiteralLength);
  maxColumnsInGroupBy = std::move(other135.maxColumnsInGroupBy);
  maxColumnsInIndex = std::move(other135.maxColumnsInIndex);
  maxColumnsInOrderBy = std::move(other135.maxColumnsInOrderBy);
  maxColumnsInSelect = std::move(other135.maxColumnsInSelect);
  maxColumnsInTable = std::move(other135.maxColumnsInTable);
  maxConnections = std::move(other135.maxConnections);
  maxIndexLength = std::move(other135.maxIndexLength);
  maxRowSize = std::move(other135.maxRowSize);
  maxStatementLength = std::move(other135.maxStatementLength);
  maxOpenStatements = std::move(other135.maxOpenStatements);
  maxTableNamesInSelect = std::move(other135.maxTableNamesInSelect);
  maxColumnNameLength = std::move(other135.maxColumnNameLength);
  maxCursorNameLength = std::move(other135.maxCursorNameLength);
  maxSchemaNameLength = std::move(other135.maxSchemaNameLength);
  maxProcedureNameLength = std::move(other135.maxProcedureNameLength);
  maxCatalogNameLength = std::move(other135.maxCatalogNameLength);
  maxTableNameLength = std::move(other135.maxTableNameLength);
  maxUserNameLength = std::move(other135.maxUserNameLength);
  defaultTransactionIsolation = std::move(other135.defaultTransactionIsolation);
  defaultResultSetType = std::move(other135.defaultResultSetType);
  defaultResultSetHoldabilityHoldCursorsOverCommit = std::move(other135.defaultResultSetHoldabilityHoldCursorsOverCommit);
  sqlStateIsXOpen = std::move(other135.sqlStateIsXOpen);
  catalogAtStart = std::move(other135.catalogAtStart);
  transactionDefaults = std::move(other135.transactionDefaults);
  rowIdLifeTime = std::move(other135.rowIdLifeTime);
  supportedFeatures = std::move(other135.supportedFeatures);
  featuresWithParams = std::move(other135.featuresWithParams);
  __isset = std::move(other135.__isset);
  return *this;
}
void ServiceMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ServiceMetaData(";
  out << "productName=" << to_string(productName);
  out << ", " << "productVersion=" << to_string(productVersion);
  out << ", " << "productMajorVersion=" << to_string(productMajorVersion);
  out << ", " << "productMinorVersion=" << to_string(productMinorVersion);
  out << ", " << "jdbcMajorVersion=" << to_string(jdbcMajorVersion);
  out << ", " << "jdbcMinorVersion=" << to_string(jdbcMinorVersion);
  out << ", " << "identifierQuote=" << to_string(identifierQuote);
  out << ", " << "sqlKeywords=" << to_string(sqlKeywords);
  out << ", " << "numericFunctions=" << to_string(numericFunctions);
  out << ", " << "stringFunctions=" << to_string(stringFunctions);
  out << ", " << "systemFunctions=" << to_string(systemFunctions);
  out << ", " << "dateTimeFunctions=" << to_string(dateTimeFunctions);
  out << ", " << "searchStringEscape=" << to_string(searchStringEscape);
  out << ", " << "extraNameCharacters="; (__isset.extraNameCharacters ? (out << to_string(extraNameCharacters)) : (out << "<null>"));
  out << ", " << "supportedCONVERT=" << to_string(supportedCONVERT);
  out << ", " << "schemaTerm=" << to_string(schemaTerm);
  out << ", " << "procedureTerm=" << to_string(procedureTerm);
  out << ", " << "catalogTerm=" << to_string(catalogTerm);
  out << ", " << "catalogSeparator=" << to_string(catalogSeparator);
  out << ", " << "maxBinaryLiteralLength=" << to_string(maxBinaryLiteralLength);
  out << ", " << "maxCharLiteralLength=" << to_string(maxCharLiteralLength);
  out << ", " << "maxColumnsInGroupBy=" << to_string(maxColumnsInGroupBy);
  out << ", " << "maxColumnsInIndex=" << to_string(maxColumnsInIndex);
  out << ", " << "maxColumnsInOrderBy=" << to_string(maxColumnsInOrderBy);
  out << ", " << "maxColumnsInSelect=" << to_string(maxColumnsInSelect);
  out << ", " << "maxColumnsInTable=" << to_string(maxColumnsInTable);
  out << ", " << "maxConnections=" << to_string(maxConnections);
  out << ", " << "maxIndexLength=" << to_string(maxIndexLength);
  out << ", " << "maxRowSize=" << to_string(maxRowSize);
  out << ", " << "maxStatementLength=" << to_string(maxStatementLength);
  out << ", " << "maxOpenStatements=" << to_string(maxOpenStatements);
  out << ", " << "maxTableNamesInSelect=" << to_string(maxTableNamesInSelect);
  out << ", " << "maxColumnNameLength=" << to_string(maxColumnNameLength);
  out << ", " << "maxCursorNameLength=" << to_string(maxCursorNameLength);
  out << ", " << "maxSchemaNameLength=" << to_string(maxSchemaNameLength);
  out << ", " << "maxProcedureNameLength=" << to_string(maxProcedureNameLength);
  out << ", " << "maxCatalogNameLength=" << to_string(maxCatalogNameLength);
  out << ", " << "maxTableNameLength=" << to_string(maxTableNameLength);
  out << ", " << "maxUserNameLength=" << to_string(maxUserNameLength);
  out << ", " << "defaultTransactionIsolation=" << to_string(defaultTransactionIsolation);
  out << ", " << "defaultResultSetType=" << to_string(defaultResultSetType);
  out << ", " << "defaultResultSetHoldabilityHoldCursorsOverCommit=" << to_string(defaultResultSetHoldabilityHoldCursorsOverCommit);
  out << ", " << "sqlStateIsXOpen=" << to_string(sqlStateIsXOpen);
  out << ", " << "catalogAtStart=" << to_string(catalogAtStart);
  out << ", " << "transactionDefaults=" << to_string(transactionDefaults);
  out << ", " << "rowIdLifeTime=" << to_string(rowIdLifeTime);
  out << ", " << "supportedFeatures=" << to_string(supportedFeatures);
  out << ", " << "featuresWithParams=" << to_string(featuresWithParams);
  out << ")";
}

}}} // namespace
