/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "SnappyDataService.h"

namespace io { namespace snappydata { namespace thrift {


SnappyDataService_getPreferredServer_args::~SnappyDataService_getPreferredServer_args() noexcept {
}


uint32_t SnappyDataService_getPreferredServer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->serverTypes.clear();
            uint32_t _size394;
            ::apache::thrift::protocol::TType _etype397;
            xfer += iprot->readSetBegin(_etype397, _size394);
            uint32_t _i398;
            for (_i398 = 0; _i398 < _size394; ++_i398)
            {
              ServerType::type _elem399;
              int32_t ecast400;
              xfer += iprot->readI32(ecast400);
              _elem399 = (ServerType::type)ecast400;
              this->serverTypes.insert(_elem399);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.serverTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->serverGroups.clear();
            uint32_t _size401;
            ::apache::thrift::protocol::TType _etype404;
            xfer += iprot->readSetBegin(_etype404, _size401);
            uint32_t _i405;
            for (_i405 = 0; _i405 < _size401; ++_i405)
            {
              std::string _elem406;
              xfer += iprot->readString(_elem406);
              this->serverGroups.insert(_elem406);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.serverGroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->failedServers.clear();
            uint32_t _size407;
            ::apache::thrift::protocol::TType _etype410;
            xfer += iprot->readSetBegin(_etype410, _size407);
            uint32_t _i411;
            for (_i411 = 0; _i411 < _size407; ++_i411)
            {
              HostAddress _elem412;
              xfer += _elem412.read(iprot);
              this->failedServers.insert(_elem412);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.failedServers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getPreferredServer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getPreferredServer_args");

  xfer += oprot->writeFieldBegin("serverTypes", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->serverTypes.size()));
    std::set<ServerType::type> ::const_iterator _iter413;
    for (_iter413 = this->serverTypes.begin(); _iter413 != this->serverTypes.end(); ++_iter413)
    {
      xfer += oprot->writeI32((int32_t)(*_iter413));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverGroups", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->serverGroups.size()));
    std::set<std::string> ::const_iterator _iter414;
    for (_iter414 = this->serverGroups.begin(); _iter414 != this->serverGroups.end(); ++_iter414)
    {
      xfer += oprot->writeString((*_iter414));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failedServers", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->failedServers.size()));
    std::set<HostAddress> ::const_iterator _iter415;
    for (_iter415 = this->failedServers.begin(); _iter415 != this->failedServers.end(); ++_iter415)
    {
      xfer += (*_iter415).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getPreferredServer_pargs::~SnappyDataService_getPreferredServer_pargs() noexcept {
}


uint32_t SnappyDataService_getPreferredServer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getPreferredServer_pargs");

  xfer += oprot->writeFieldBegin("serverTypes", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->serverTypes)).size()));
    std::set<ServerType::type> ::const_iterator _iter416;
    for (_iter416 = (*(this->serverTypes)).begin(); _iter416 != (*(this->serverTypes)).end(); ++_iter416)
    {
      xfer += oprot->writeI32((int32_t)(*_iter416));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverGroups", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->serverGroups)).size()));
    std::set<std::string> ::const_iterator _iter417;
    for (_iter417 = (*(this->serverGroups)).begin(); _iter417 != (*(this->serverGroups)).end(); ++_iter417)
    {
      xfer += oprot->writeString((*_iter417));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failedServers", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->failedServers)).size()));
    std::set<HostAddress> ::const_iterator _iter418;
    for (_iter418 = (*(this->failedServers)).begin(); _iter418 != (*(this->failedServers)).end(); ++_iter418)
    {
      xfer += (*_iter418).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getPreferredServer_result::~SnappyDataService_getPreferredServer_result() noexcept {
}


uint32_t SnappyDataService_getPreferredServer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getPreferredServer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getPreferredServer_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getPreferredServer_presult::~SnappyDataService_getPreferredServer_presult() noexcept {
}


uint32_t SnappyDataService_getPreferredServer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getAllServersWithPreferredServer_args::~SnappyDataService_getAllServersWithPreferredServer_args() noexcept {
}


uint32_t SnappyDataService_getAllServersWithPreferredServer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->serverTypes.clear();
            uint32_t _size419;
            ::apache::thrift::protocol::TType _etype422;
            xfer += iprot->readSetBegin(_etype422, _size419);
            uint32_t _i423;
            for (_i423 = 0; _i423 < _size419; ++_i423)
            {
              ServerType::type _elem424;
              int32_t ecast425;
              xfer += iprot->readI32(ecast425);
              _elem424 = (ServerType::type)ecast425;
              this->serverTypes.insert(_elem424);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.serverTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->serverGroups.clear();
            uint32_t _size426;
            ::apache::thrift::protocol::TType _etype429;
            xfer += iprot->readSetBegin(_etype429, _size426);
            uint32_t _i430;
            for (_i430 = 0; _i430 < _size426; ++_i430)
            {
              std::string _elem431;
              xfer += iprot->readString(_elem431);
              this->serverGroups.insert(_elem431);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.serverGroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->failedServers.clear();
            uint32_t _size432;
            ::apache::thrift::protocol::TType _etype435;
            xfer += iprot->readSetBegin(_etype435, _size432);
            uint32_t _i436;
            for (_i436 = 0; _i436 < _size432; ++_i436)
            {
              HostAddress _elem437;
              xfer += _elem437.read(iprot);
              this->failedServers.insert(_elem437);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.failedServers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getAllServersWithPreferredServer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getAllServersWithPreferredServer_args");

  xfer += oprot->writeFieldBegin("serverTypes", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->serverTypes.size()));
    std::set<ServerType::type> ::const_iterator _iter438;
    for (_iter438 = this->serverTypes.begin(); _iter438 != this->serverTypes.end(); ++_iter438)
    {
      xfer += oprot->writeI32((int32_t)(*_iter438));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverGroups", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->serverGroups.size()));
    std::set<std::string> ::const_iterator _iter439;
    for (_iter439 = this->serverGroups.begin(); _iter439 != this->serverGroups.end(); ++_iter439)
    {
      xfer += oprot->writeString((*_iter439));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failedServers", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->failedServers.size()));
    std::set<HostAddress> ::const_iterator _iter440;
    for (_iter440 = this->failedServers.begin(); _iter440 != this->failedServers.end(); ++_iter440)
    {
      xfer += (*_iter440).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getAllServersWithPreferredServer_pargs::~SnappyDataService_getAllServersWithPreferredServer_pargs() noexcept {
}


uint32_t SnappyDataService_getAllServersWithPreferredServer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getAllServersWithPreferredServer_pargs");

  xfer += oprot->writeFieldBegin("serverTypes", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->serverTypes)).size()));
    std::set<ServerType::type> ::const_iterator _iter441;
    for (_iter441 = (*(this->serverTypes)).begin(); _iter441 != (*(this->serverTypes)).end(); ++_iter441)
    {
      xfer += oprot->writeI32((int32_t)(*_iter441));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverGroups", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->serverGroups)).size()));
    std::set<std::string> ::const_iterator _iter442;
    for (_iter442 = (*(this->serverGroups)).begin(); _iter442 != (*(this->serverGroups)).end(); ++_iter442)
    {
      xfer += oprot->writeString((*_iter442));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failedServers", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->failedServers)).size()));
    std::set<HostAddress> ::const_iterator _iter443;
    for (_iter443 = (*(this->failedServers)).begin(); _iter443 != (*(this->failedServers)).end(); ++_iter443)
    {
      xfer += (*_iter443).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getAllServersWithPreferredServer_result::~SnappyDataService_getAllServersWithPreferredServer_result() noexcept {
}


uint32_t SnappyDataService_getAllServersWithPreferredServer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size444;
            ::apache::thrift::protocol::TType _etype447;
            xfer += iprot->readListBegin(_etype447, _size444);
            this->success.resize(_size444);
            uint32_t _i448;
            for (_i448 = 0; _i448 < _size444; ++_i448)
            {
              xfer += this->success[_i448].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getAllServersWithPreferredServer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getAllServersWithPreferredServer_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<HostAddress> ::const_iterator _iter449;
      for (_iter449 = this->success.begin(); _iter449 != this->success.end(); ++_iter449)
      {
        xfer += (*_iter449).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getAllServersWithPreferredServer_presult::~SnappyDataService_getAllServersWithPreferredServer_presult() noexcept {
}


uint32_t SnappyDataService_getAllServersWithPreferredServer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size450;
            ::apache::thrift::protocol::TType _etype453;
            xfer += iprot->readListBegin(_etype453, _size450);
            (*(this->success)).resize(_size450);
            uint32_t _i454;
            for (_i454 = 0; _i454 < _size450; ++_i454)
            {
              xfer += (*(this->success))[_i454].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_openConnection_args::~SnappyDataService_openConnection_args() noexcept {
}


uint32_t SnappyDataService_openConnection_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->arguments.read(iprot);
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_openConnection_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_openConnection_args");

  xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->arguments.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_openConnection_pargs::~SnappyDataService_openConnection_pargs() noexcept {
}


uint32_t SnappyDataService_openConnection_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_openConnection_pargs");

  xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->arguments)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_openConnection_result::~SnappyDataService_openConnection_result() noexcept {
}


uint32_t SnappyDataService_openConnection_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_openConnection_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_openConnection_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_openConnection_presult::~SnappyDataService_openConnection_presult() noexcept {
}


uint32_t SnappyDataService_openConnection_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_execute_args::~SnappyDataService_execute_args() noexcept {
}


uint32_t SnappyDataService_execute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          this->__isset.sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->outputParams.clear();
            uint32_t _size455;
            ::apache::thrift::protocol::TType _ktype456;
            ::apache::thrift::protocol::TType _vtype457;
            xfer += iprot->readMapBegin(_ktype456, _vtype457, _size455);
            uint32_t _i459;
            for (_i459 = 0; _i459 < _size455; ++_i459)
            {
              int32_t _key460;
              xfer += iprot->readI32(_key460);
              OutputParameter& _val461 = this->outputParams[_key460];
              xfer += _val461.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.outputParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attrs.read(iprot);
          this->__isset.attrs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_execute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_execute_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputParams.size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter462;
    for (_iter462 = this->outputParams.begin(); _iter462 != this->outputParams.end(); ++_iter462)
    {
      xfer += oprot->writeI32(_iter462->first);
      xfer += _iter462->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->attrs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_execute_pargs::~SnappyDataService_execute_pargs() noexcept {
}


uint32_t SnappyDataService_execute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_execute_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->sql)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->outputParams)).size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter463;
    for (_iter463 = (*(this->outputParams)).begin(); _iter463 != (*(this->outputParams)).end(); ++_iter463)
    {
      xfer += oprot->writeI32(_iter463->first);
      xfer += _iter463->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->attrs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_execute_result::~SnappyDataService_execute_result() noexcept {
}


uint32_t SnappyDataService_execute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_execute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_execute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_execute_presult::~SnappyDataService_execute_presult() noexcept {
}


uint32_t SnappyDataService_execute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executeUpdate_args::~SnappyDataService_executeUpdate_args() noexcept {
}


uint32_t SnappyDataService_executeUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sqls.clear();
            uint32_t _size464;
            ::apache::thrift::protocol::TType _etype467;
            xfer += iprot->readListBegin(_etype467, _size464);
            this->sqls.resize(_size464);
            uint32_t _i468;
            for (_i468 = 0; _i468 < _size464; ++_i468)
            {
              xfer += iprot->readString(this->sqls[_i468]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sqls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attrs.read(iprot);
          this->__isset.attrs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeUpdate_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqls", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sqls.size()));
    std::vector<std::string> ::const_iterator _iter469;
    for (_iter469 = this->sqls.begin(); _iter469 != this->sqls.end(); ++_iter469)
    {
      xfer += oprot->writeString((*_iter469));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->attrs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeUpdate_pargs::~SnappyDataService_executeUpdate_pargs() noexcept {
}


uint32_t SnappyDataService_executeUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeUpdate_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqls", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->sqls)).size()));
    std::vector<std::string> ::const_iterator _iter470;
    for (_iter470 = (*(this->sqls)).begin(); _iter470 != (*(this->sqls)).end(); ++_iter470)
    {
      xfer += oprot->writeString((*_iter470));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->attrs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeUpdate_result::~SnappyDataService_executeUpdate_result() noexcept {
}


uint32_t SnappyDataService_executeUpdate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeUpdate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executeUpdate_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeUpdate_presult::~SnappyDataService_executeUpdate_presult() noexcept {
}


uint32_t SnappyDataService_executeUpdate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executeQuery_args::~SnappyDataService_executeQuery_args() noexcept {
}


uint32_t SnappyDataService_executeQuery_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          this->__isset.sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attrs.read(iprot);
          this->__isset.attrs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeQuery_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeQuery_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->attrs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeQuery_pargs::~SnappyDataService_executeQuery_pargs() noexcept {
}


uint32_t SnappyDataService_executeQuery_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeQuery_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->sql)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->attrs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeQuery_result::~SnappyDataService_executeQuery_result() noexcept {
}


uint32_t SnappyDataService_executeQuery_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeQuery_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executeQuery_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeQuery_presult::~SnappyDataService_executeQuery_presult() noexcept {
}


uint32_t SnappyDataService_executeQuery_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_prepareStatement_args::~SnappyDataService_prepareStatement_args() noexcept {
}


uint32_t SnappyDataService_prepareStatement_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          this->__isset.sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->outputParams.clear();
            uint32_t _size471;
            ::apache::thrift::protocol::TType _ktype472;
            ::apache::thrift::protocol::TType _vtype473;
            xfer += iprot->readMapBegin(_ktype472, _vtype473, _size471);
            uint32_t _i475;
            for (_i475 = 0; _i475 < _size471; ++_i475)
            {
              int32_t _key476;
              xfer += iprot->readI32(_key476);
              OutputParameter& _val477 = this->outputParams[_key476];
              xfer += _val477.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.outputParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attrs.read(iprot);
          this->__isset.attrs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareStatement_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareStatement_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputParams.size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter478;
    for (_iter478 = this->outputParams.begin(); _iter478 != this->outputParams.end(); ++_iter478)
    {
      xfer += oprot->writeI32(_iter478->first);
      xfer += _iter478->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->attrs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareStatement_pargs::~SnappyDataService_prepareStatement_pargs() noexcept {
}


uint32_t SnappyDataService_prepareStatement_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareStatement_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->sql)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->outputParams)).size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter479;
    for (_iter479 = (*(this->outputParams)).begin(); _iter479 != (*(this->outputParams)).end(); ++_iter479)
    {
      xfer += oprot->writeI32(_iter479->first);
      xfer += _iter479->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->attrs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareStatement_result::~SnappyDataService_prepareStatement_result() noexcept {
}


uint32_t SnappyDataService_prepareStatement_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareStatement_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_prepareStatement_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareStatement_presult::~SnappyDataService_prepareStatement_presult() noexcept {
}


uint32_t SnappyDataService_prepareStatement_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executePrepared_args::~SnappyDataService_executePrepared_args() noexcept {
}


uint32_t SnappyDataService_executePrepared_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->outputParams.clear();
            uint32_t _size480;
            ::apache::thrift::protocol::TType _ktype481;
            ::apache::thrift::protocol::TType _vtype482;
            xfer += iprot->readMapBegin(_ktype481, _vtype482, _size480);
            uint32_t _i484;
            for (_i484 = 0; _i484 < _size480; ++_i484)
            {
              int32_t _key485;
              xfer += iprot->readI32(_key485);
              OutputParameter& _val486 = this->outputParams[_key485];
              xfer += _val486.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.outputParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePrepared_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePrepared_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputParams.size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter487;
    for (_iter487 = this->outputParams.begin(); _iter487 != this->outputParams.end(); ++_iter487)
    {
      xfer += oprot->writeI32(_iter487->first);
      xfer += _iter487->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePrepared_pargs::~SnappyDataService_executePrepared_pargs() noexcept {
}


uint32_t SnappyDataService_executePrepared_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePrepared_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->params)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->outputParams)).size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter488;
    for (_iter488 = (*(this->outputParams)).begin(); _iter488 != (*(this->outputParams)).end(); ++_iter488)
    {
      xfer += oprot->writeI32(_iter488->first);
      xfer += _iter488->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePrepared_result::~SnappyDataService_executePrepared_result() noexcept {
}


uint32_t SnappyDataService_executePrepared_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePrepared_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executePrepared_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePrepared_presult::~SnappyDataService_executePrepared_presult() noexcept {
}


uint32_t SnappyDataService_executePrepared_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executePreparedUpdate_args::~SnappyDataService_executePreparedUpdate_args() noexcept {
}


uint32_t SnappyDataService_executePreparedUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedUpdate_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedUpdate_pargs::~SnappyDataService_executePreparedUpdate_pargs() noexcept {
}


uint32_t SnappyDataService_executePreparedUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedUpdate_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->params)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedUpdate_result::~SnappyDataService_executePreparedUpdate_result() noexcept {
}


uint32_t SnappyDataService_executePreparedUpdate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedUpdate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedUpdate_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedUpdate_presult::~SnappyDataService_executePreparedUpdate_presult() noexcept {
}


uint32_t SnappyDataService_executePreparedUpdate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executePreparedQuery_args::~SnappyDataService_executePreparedQuery_args() noexcept {
}


uint32_t SnappyDataService_executePreparedQuery_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedQuery_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedQuery_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedQuery_pargs::~SnappyDataService_executePreparedQuery_pargs() noexcept {
}


uint32_t SnappyDataService_executePreparedQuery_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedQuery_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->params)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedQuery_result::~SnappyDataService_executePreparedQuery_result() noexcept {
}


uint32_t SnappyDataService_executePreparedQuery_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedQuery_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedQuery_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedQuery_presult::~SnappyDataService_executePreparedQuery_presult() noexcept {
}


uint32_t SnappyDataService_executePreparedQuery_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executePreparedBatch_args::~SnappyDataService_executePreparedBatch_args() noexcept {
}


uint32_t SnappyDataService_executePreparedBatch_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paramsBatch.clear();
            uint32_t _size489;
            ::apache::thrift::protocol::TType _etype492;
            xfer += iprot->readListBegin(_etype492, _size489);
            this->paramsBatch.resize(_size489);
            uint32_t _i493;
            for (_i493 = 0; _i493 < _size489; ++_i493)
            {
              xfer += this->paramsBatch[_i493].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.paramsBatch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedBatch_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedBatch_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramsBatch", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->paramsBatch.size()));
    std::vector<Row> ::const_iterator _iter494;
    for (_iter494 = this->paramsBatch.begin(); _iter494 != this->paramsBatch.end(); ++_iter494)
    {
      xfer += (*_iter494).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedBatch_pargs::~SnappyDataService_executePreparedBatch_pargs() noexcept {
}


uint32_t SnappyDataService_executePreparedBatch_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedBatch_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramsBatch", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->paramsBatch)).size()));
    std::vector<Row> ::const_iterator _iter495;
    for (_iter495 = (*(this->paramsBatch)).begin(); _iter495 != (*(this->paramsBatch)).end(); ++_iter495)
    {
      xfer += (*_iter495).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedBatch_result::~SnappyDataService_executePreparedBatch_result() noexcept {
}


uint32_t SnappyDataService_executePreparedBatch_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedBatch_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedBatch_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedBatch_presult::~SnappyDataService_executePreparedBatch_presult() noexcept {
}


uint32_t SnappyDataService_executePreparedBatch_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_prepareAndExecute_args::~SnappyDataService_prepareAndExecute_args() noexcept {
}


uint32_t SnappyDataService_prepareAndExecute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          this->__isset.sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paramsBatch.clear();
            uint32_t _size496;
            ::apache::thrift::protocol::TType _etype499;
            xfer += iprot->readListBegin(_etype499, _size496);
            this->paramsBatch.resize(_size496);
            uint32_t _i500;
            for (_i500 = 0; _i500 < _size496; ++_i500)
            {
              xfer += this->paramsBatch[_i500].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.paramsBatch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->outputParams.clear();
            uint32_t _size501;
            ::apache::thrift::protocol::TType _ktype502;
            ::apache::thrift::protocol::TType _vtype503;
            xfer += iprot->readMapBegin(_ktype502, _vtype503, _size501);
            uint32_t _i505;
            for (_i505 = 0; _i505 < _size501; ++_i505)
            {
              int32_t _key506;
              xfer += iprot->readI32(_key506);
              OutputParameter& _val507 = this->outputParams[_key506];
              xfer += _val507.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.outputParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attrs.read(iprot);
          this->__isset.attrs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareAndExecute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareAndExecute_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramsBatch", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->paramsBatch.size()));
    std::vector<Row> ::const_iterator _iter508;
    for (_iter508 = this->paramsBatch.begin(); _iter508 != this->paramsBatch.end(); ++_iter508)
    {
      xfer += (*_iter508).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputParams.size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter509;
    for (_iter509 = this->outputParams.begin(); _iter509 != this->outputParams.end(); ++_iter509)
    {
      xfer += oprot->writeI32(_iter509->first);
      xfer += _iter509->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->attrs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareAndExecute_pargs::~SnappyDataService_prepareAndExecute_pargs() noexcept {
}


uint32_t SnappyDataService_prepareAndExecute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareAndExecute_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->sql)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramsBatch", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->paramsBatch)).size()));
    std::vector<Row> ::const_iterator _iter510;
    for (_iter510 = (*(this->paramsBatch)).begin(); _iter510 != (*(this->paramsBatch)).end(); ++_iter510)
    {
      xfer += (*_iter510).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->outputParams)).size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter511;
    for (_iter511 = (*(this->outputParams)).begin(); _iter511 != (*(this->outputParams)).end(); ++_iter511)
    {
      xfer += oprot->writeI32(_iter511->first);
      xfer += _iter511->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += (*(this->attrs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareAndExecute_result::~SnappyDataService_prepareAndExecute_result() noexcept {
}


uint32_t SnappyDataService_prepareAndExecute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareAndExecute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_prepareAndExecute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareAndExecute_presult::~SnappyDataService_prepareAndExecute_presult() noexcept {
}


uint32_t SnappyDataService_prepareAndExecute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_beginTransaction_args::~SnappyDataService_beginTransaction_args() noexcept {
}


uint32_t SnappyDataService_beginTransaction_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->isolationLevel);
          this->__isset.isolationLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->flags.clear();
            uint32_t _size512;
            ::apache::thrift::protocol::TType _ktype513;
            ::apache::thrift::protocol::TType _vtype514;
            xfer += iprot->readMapBegin(_ktype513, _vtype514, _size512);
            uint32_t _i516;
            for (_i516 = 0; _i516 < _size512; ++_i516)
            {
              TransactionAttribute::type _key517;
              int32_t ecast519;
              xfer += iprot->readI32(ecast519);
              _key517 = (TransactionAttribute::type)ecast519;
              bool& _val518 = this->flags[_key517];
              xfer += iprot->readBool(_val518);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_beginTransaction_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_beginTransaction_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isolationLevel", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->isolationLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->flags.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter520;
    for (_iter520 = this->flags.begin(); _iter520 != this->flags.end(); ++_iter520)
    {
      xfer += oprot->writeI32((int32_t)_iter520->first);
      xfer += oprot->writeBool(_iter520->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_beginTransaction_pargs::~SnappyDataService_beginTransaction_pargs() noexcept {
}


uint32_t SnappyDataService_beginTransaction_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_beginTransaction_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isolationLevel", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->isolationLevel)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*(this->flags)).size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter521;
    for (_iter521 = (*(this->flags)).begin(); _iter521 != (*(this->flags)).end(); ++_iter521)
    {
      xfer += oprot->writeI32((int32_t)_iter521->first);
      xfer += oprot->writeBool(_iter521->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_beginTransaction_result::~SnappyDataService_beginTransaction_result() noexcept {
}


uint32_t SnappyDataService_beginTransaction_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_beginTransaction_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_beginTransaction_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_beginTransaction_presult::~SnappyDataService_beginTransaction_presult() noexcept {
}


uint32_t SnappyDataService_beginTransaction_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_setTransactionAttributes_args::~SnappyDataService_setTransactionAttributes_args() noexcept {
}


uint32_t SnappyDataService_setTransactionAttributes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->flags.clear();
            uint32_t _size522;
            ::apache::thrift::protocol::TType _ktype523;
            ::apache::thrift::protocol::TType _vtype524;
            xfer += iprot->readMapBegin(_ktype523, _vtype524, _size522);
            uint32_t _i526;
            for (_i526 = 0; _i526 < _size522; ++_i526)
            {
              TransactionAttribute::type _key527;
              int32_t ecast529;
              xfer += iprot->readI32(ecast529);
              _key527 = (TransactionAttribute::type)ecast529;
              bool& _val528 = this->flags[_key527];
              xfer += iprot->readBool(_val528);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_setTransactionAttributes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_setTransactionAttributes_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->flags.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter530;
    for (_iter530 = this->flags.begin(); _iter530 != this->flags.end(); ++_iter530)
    {
      xfer += oprot->writeI32((int32_t)_iter530->first);
      xfer += oprot->writeBool(_iter530->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_setTransactionAttributes_pargs::~SnappyDataService_setTransactionAttributes_pargs() noexcept {
}


uint32_t SnappyDataService_setTransactionAttributes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_setTransactionAttributes_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*(this->flags)).size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter531;
    for (_iter531 = (*(this->flags)).begin(); _iter531 != (*(this->flags)).end(); ++_iter531)
    {
      xfer += oprot->writeI32((int32_t)_iter531->first);
      xfer += oprot->writeBool(_iter531->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_setTransactionAttributes_result::~SnappyDataService_setTransactionAttributes_result() noexcept {
}


uint32_t SnappyDataService_setTransactionAttributes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_setTransactionAttributes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_setTransactionAttributes_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_setTransactionAttributes_presult::~SnappyDataService_setTransactionAttributes_presult() noexcept {
}


uint32_t SnappyDataService_setTransactionAttributes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getTransactionAttributes_args::~SnappyDataService_getTransactionAttributes_args() noexcept {
}


uint32_t SnappyDataService_getTransactionAttributes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getTransactionAttributes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getTransactionAttributes_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getTransactionAttributes_pargs::~SnappyDataService_getTransactionAttributes_pargs() noexcept {
}


uint32_t SnappyDataService_getTransactionAttributes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getTransactionAttributes_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getTransactionAttributes_result::~SnappyDataService_getTransactionAttributes_result() noexcept {
}


uint32_t SnappyDataService_getTransactionAttributes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size532;
            ::apache::thrift::protocol::TType _ktype533;
            ::apache::thrift::protocol::TType _vtype534;
            xfer += iprot->readMapBegin(_ktype533, _vtype534, _size532);
            uint32_t _i536;
            for (_i536 = 0; _i536 < _size532; ++_i536)
            {
              TransactionAttribute::type _key537;
              int32_t ecast539;
              xfer += iprot->readI32(ecast539);
              _key537 = (TransactionAttribute::type)ecast539;
              bool& _val538 = this->success[_key537];
              xfer += iprot->readBool(_val538);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getTransactionAttributes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getTransactionAttributes_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->success.size()));
      std::map<TransactionAttribute::type, bool> ::const_iterator _iter540;
      for (_iter540 = this->success.begin(); _iter540 != this->success.end(); ++_iter540)
      {
        xfer += oprot->writeI32((int32_t)_iter540->first);
        xfer += oprot->writeBool(_iter540->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getTransactionAttributes_presult::~SnappyDataService_getTransactionAttributes_presult() noexcept {
}


uint32_t SnappyDataService_getTransactionAttributes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size541;
            ::apache::thrift::protocol::TType _ktype542;
            ::apache::thrift::protocol::TType _vtype543;
            xfer += iprot->readMapBegin(_ktype542, _vtype543, _size541);
            uint32_t _i545;
            for (_i545 = 0; _i545 < _size541; ++_i545)
            {
              TransactionAttribute::type _key546;
              int32_t ecast548;
              xfer += iprot->readI32(ecast548);
              _key546 = (TransactionAttribute::type)ecast548;
              bool& _val547 = (*(this->success))[_key546];
              xfer += iprot->readBool(_val547);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_commitTransaction_args::~SnappyDataService_commitTransaction_args() noexcept {
}


uint32_t SnappyDataService_commitTransaction_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->startNewTransaction);
          this->__isset.startNewTransaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->flags.clear();
            uint32_t _size549;
            ::apache::thrift::protocol::TType _ktype550;
            ::apache::thrift::protocol::TType _vtype551;
            xfer += iprot->readMapBegin(_ktype550, _vtype551, _size549);
            uint32_t _i553;
            for (_i553 = 0; _i553 < _size549; ++_i553)
            {
              TransactionAttribute::type _key554;
              int32_t ecast556;
              xfer += iprot->readI32(ecast556);
              _key554 = (TransactionAttribute::type)ecast556;
              bool& _val555 = this->flags[_key554];
              xfer += iprot->readBool(_val555);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_commitTransaction_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_commitTransaction_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startNewTransaction", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->startNewTransaction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->flags.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter557;
    for (_iter557 = this->flags.begin(); _iter557 != this->flags.end(); ++_iter557)
    {
      xfer += oprot->writeI32((int32_t)_iter557->first);
      xfer += oprot->writeBool(_iter557->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_commitTransaction_pargs::~SnappyDataService_commitTransaction_pargs() noexcept {
}


uint32_t SnappyDataService_commitTransaction_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_commitTransaction_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startNewTransaction", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->startNewTransaction)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*(this->flags)).size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter558;
    for (_iter558 = (*(this->flags)).begin(); _iter558 != (*(this->flags)).end(); ++_iter558)
    {
      xfer += oprot->writeI32((int32_t)_iter558->first);
      xfer += oprot->writeBool(_iter558->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_commitTransaction_result::~SnappyDataService_commitTransaction_result() noexcept {
}


uint32_t SnappyDataService_commitTransaction_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_commitTransaction_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_commitTransaction_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_commitTransaction_presult::~SnappyDataService_commitTransaction_presult() noexcept {
}


uint32_t SnappyDataService_commitTransaction_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_rollbackTransaction_args::~SnappyDataService_rollbackTransaction_args() noexcept {
}


uint32_t SnappyDataService_rollbackTransaction_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->startNewTransaction);
          this->__isset.startNewTransaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->flags.clear();
            uint32_t _size559;
            ::apache::thrift::protocol::TType _ktype560;
            ::apache::thrift::protocol::TType _vtype561;
            xfer += iprot->readMapBegin(_ktype560, _vtype561, _size559);
            uint32_t _i563;
            for (_i563 = 0; _i563 < _size559; ++_i563)
            {
              TransactionAttribute::type _key564;
              int32_t ecast566;
              xfer += iprot->readI32(ecast566);
              _key564 = (TransactionAttribute::type)ecast566;
              bool& _val565 = this->flags[_key564];
              xfer += iprot->readBool(_val565);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_rollbackTransaction_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_rollbackTransaction_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startNewTransaction", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->startNewTransaction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->flags.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter567;
    for (_iter567 = this->flags.begin(); _iter567 != this->flags.end(); ++_iter567)
    {
      xfer += oprot->writeI32((int32_t)_iter567->first);
      xfer += oprot->writeBool(_iter567->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_rollbackTransaction_pargs::~SnappyDataService_rollbackTransaction_pargs() noexcept {
}


uint32_t SnappyDataService_rollbackTransaction_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_rollbackTransaction_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startNewTransaction", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->startNewTransaction)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*(this->flags)).size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter568;
    for (_iter568 = (*(this->flags)).begin(); _iter568 != (*(this->flags)).end(); ++_iter568)
    {
      xfer += oprot->writeI32((int32_t)_iter568->first);
      xfer += oprot->writeBool(_iter568->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_rollbackTransaction_result::~SnappyDataService_rollbackTransaction_result() noexcept {
}


uint32_t SnappyDataService_rollbackTransaction_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_rollbackTransaction_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_rollbackTransaction_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_rollbackTransaction_presult::~SnappyDataService_rollbackTransaction_presult() noexcept {
}


uint32_t SnappyDataService_rollbackTransaction_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_prepareCommitTransaction_args::~SnappyDataService_prepareCommitTransaction_args() noexcept {
}


uint32_t SnappyDataService_prepareCommitTransaction_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->flags.clear();
            uint32_t _size569;
            ::apache::thrift::protocol::TType _ktype570;
            ::apache::thrift::protocol::TType _vtype571;
            xfer += iprot->readMapBegin(_ktype570, _vtype571, _size569);
            uint32_t _i573;
            for (_i573 = 0; _i573 < _size569; ++_i573)
            {
              TransactionAttribute::type _key574;
              int32_t ecast576;
              xfer += iprot->readI32(ecast576);
              _key574 = (TransactionAttribute::type)ecast576;
              bool& _val575 = this->flags[_key574];
              xfer += iprot->readBool(_val575);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareCommitTransaction_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareCommitTransaction_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->flags.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter577;
    for (_iter577 = this->flags.begin(); _iter577 != this->flags.end(); ++_iter577)
    {
      xfer += oprot->writeI32((int32_t)_iter577->first);
      xfer += oprot->writeBool(_iter577->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareCommitTransaction_pargs::~SnappyDataService_prepareCommitTransaction_pargs() noexcept {
}


uint32_t SnappyDataService_prepareCommitTransaction_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareCommitTransaction_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*(this->flags)).size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter578;
    for (_iter578 = (*(this->flags)).begin(); _iter578 != (*(this->flags)).end(); ++_iter578)
    {
      xfer += oprot->writeI32((int32_t)_iter578->first);
      xfer += oprot->writeBool(_iter578->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareCommitTransaction_result::~SnappyDataService_prepareCommitTransaction_result() noexcept {
}


uint32_t SnappyDataService_prepareCommitTransaction_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareCommitTransaction_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_prepareCommitTransaction_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareCommitTransaction_presult::~SnappyDataService_prepareCommitTransaction_presult() noexcept {
}


uint32_t SnappyDataService_prepareCommitTransaction_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getNextResultSet_args::~SnappyDataService_getNextResultSet_args() noexcept {
}


uint32_t SnappyDataService_getNextResultSet_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cursorId);
          this->__isset.cursorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->otherResultSetBehaviour);
          this->__isset.otherResultSetBehaviour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getNextResultSet_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getNextResultSet_args");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cursorId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("otherResultSetBehaviour", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->otherResultSetBehaviour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getNextResultSet_pargs::~SnappyDataService_getNextResultSet_pargs() noexcept {
}


uint32_t SnappyDataService_getNextResultSet_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getNextResultSet_pargs");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->cursorId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("otherResultSetBehaviour", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->otherResultSetBehaviour)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getNextResultSet_result::~SnappyDataService_getNextResultSet_result() noexcept {
}


uint32_t SnappyDataService_getNextResultSet_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getNextResultSet_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getNextResultSet_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getNextResultSet_presult::~SnappyDataService_getNextResultSet_presult() noexcept {
}


uint32_t SnappyDataService_getNextResultSet_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getBlobChunk_args::~SnappyDataService_getBlobChunk_args() noexcept {
}


uint32_t SnappyDataService_getBlobChunk_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lobId);
          this->__isset.lobId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->freeLobAtEnd);
          this->__isset.freeLobAtEnd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getBlobChunk_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getBlobChunk_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->lobId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeLobAtEnd", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->freeLobAtEnd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBlobChunk_pargs::~SnappyDataService_getBlobChunk_pargs() noexcept {
}


uint32_t SnappyDataService_getBlobChunk_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getBlobChunk_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->lobId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->size)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeLobAtEnd", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->freeLobAtEnd)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBlobChunk_result::~SnappyDataService_getBlobChunk_result() noexcept {
}


uint32_t SnappyDataService_getBlobChunk_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getBlobChunk_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getBlobChunk_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBlobChunk_presult::~SnappyDataService_getBlobChunk_presult() noexcept {
}


uint32_t SnappyDataService_getBlobChunk_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getClobChunk_args::~SnappyDataService_getClobChunk_args() noexcept {
}


uint32_t SnappyDataService_getClobChunk_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lobId);
          this->__isset.lobId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->freeLobAtEnd);
          this->__isset.freeLobAtEnd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getClobChunk_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getClobChunk_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->lobId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeLobAtEnd", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->freeLobAtEnd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getClobChunk_pargs::~SnappyDataService_getClobChunk_pargs() noexcept {
}


uint32_t SnappyDataService_getClobChunk_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getClobChunk_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->lobId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->size)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeLobAtEnd", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->freeLobAtEnd)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getClobChunk_result::~SnappyDataService_getClobChunk_result() noexcept {
}


uint32_t SnappyDataService_getClobChunk_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getClobChunk_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getClobChunk_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getClobChunk_presult::~SnappyDataService_getClobChunk_presult() noexcept {
}


uint32_t SnappyDataService_getClobChunk_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_sendBlobChunk_args::~SnappyDataService_sendBlobChunk_args() noexcept {
}


uint32_t SnappyDataService_sendBlobChunk_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->chunk.read(iprot);
          this->__isset.chunk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_sendBlobChunk_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_sendBlobChunk_args");

  xfer += oprot->writeFieldBegin("chunk", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->chunk.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendBlobChunk_pargs::~SnappyDataService_sendBlobChunk_pargs() noexcept {
}


uint32_t SnappyDataService_sendBlobChunk_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_sendBlobChunk_pargs");

  xfer += oprot->writeFieldBegin("chunk", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->chunk)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendBlobChunk_result::~SnappyDataService_sendBlobChunk_result() noexcept {
}


uint32_t SnappyDataService_sendBlobChunk_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_sendBlobChunk_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_sendBlobChunk_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendBlobChunk_presult::~SnappyDataService_sendBlobChunk_presult() noexcept {
}


uint32_t SnappyDataService_sendBlobChunk_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_sendClobChunk_args::~SnappyDataService_sendClobChunk_args() noexcept {
}


uint32_t SnappyDataService_sendClobChunk_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->chunk.read(iprot);
          this->__isset.chunk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_sendClobChunk_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_sendClobChunk_args");

  xfer += oprot->writeFieldBegin("chunk", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->chunk.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendClobChunk_pargs::~SnappyDataService_sendClobChunk_pargs() noexcept {
}


uint32_t SnappyDataService_sendClobChunk_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_sendClobChunk_pargs");

  xfer += oprot->writeFieldBegin("chunk", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->chunk)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendClobChunk_result::~SnappyDataService_sendClobChunk_result() noexcept {
}


uint32_t SnappyDataService_sendClobChunk_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_sendClobChunk_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_sendClobChunk_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendClobChunk_presult::~SnappyDataService_sendClobChunk_presult() noexcept {
}


uint32_t SnappyDataService_sendClobChunk_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_freeLob_args::~SnappyDataService_freeLob_args() noexcept {
}


uint32_t SnappyDataService_freeLob_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lobId);
          this->__isset.lobId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_freeLob_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_freeLob_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->lobId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_freeLob_pargs::~SnappyDataService_freeLob_pargs() noexcept {
}


uint32_t SnappyDataService_freeLob_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_freeLob_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->lobId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_freeLob_result::~SnappyDataService_freeLob_result() noexcept {
}


uint32_t SnappyDataService_freeLob_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_freeLob_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_freeLob_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_freeLob_presult::~SnappyDataService_freeLob_presult() noexcept {
}


uint32_t SnappyDataService_freeLob_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_scrollCursor_args::~SnappyDataService_scrollCursor_args() noexcept {
}


uint32_t SnappyDataService_scrollCursor_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cursorId);
          this->__isset.cursorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->offsetIsAbsolute);
          this->__isset.offsetIsAbsolute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->fetchReverse);
          this->__isset.fetchReverse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_scrollCursor_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_scrollCursor_args");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cursorId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offsetIsAbsolute", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->offsetIsAbsolute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fetchReverse", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->fetchReverse);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->fetchSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_scrollCursor_pargs::~SnappyDataService_scrollCursor_pargs() noexcept {
}


uint32_t SnappyDataService_scrollCursor_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_scrollCursor_pargs");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->cursorId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offsetIsAbsolute", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->offsetIsAbsolute)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fetchReverse", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->fetchReverse)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->fetchSize)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_scrollCursor_result::~SnappyDataService_scrollCursor_result() noexcept {
}


uint32_t SnappyDataService_scrollCursor_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_scrollCursor_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_scrollCursor_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_scrollCursor_presult::~SnappyDataService_scrollCursor_presult() noexcept {
}


uint32_t SnappyDataService_scrollCursor_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executeCursorUpdate_args::~SnappyDataService_executeCursorUpdate_args() noexcept {
}


uint32_t SnappyDataService_executeCursorUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cursorId);
          this->__isset.cursorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->operations.clear();
            uint32_t _size579;
            ::apache::thrift::protocol::TType _etype582;
            xfer += iprot->readListBegin(_etype582, _size579);
            this->operations.resize(_size579);
            uint32_t _i583;
            for (_i583 = 0; _i583 < _size579; ++_i583)
            {
              int32_t ecast584;
              xfer += iprot->readI32(ecast584);
              this->operations[_i583] = (CursorUpdateOperation::type)ecast584;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.operations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->changedRows.clear();
            uint32_t _size585;
            ::apache::thrift::protocol::TType _etype588;
            xfer += iprot->readListBegin(_etype588, _size585);
            this->changedRows.resize(_size585);
            uint32_t _i589;
            for (_i589 = 0; _i589 < _size585; ++_i589)
            {
              xfer += this->changedRows[_i589].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.changedRows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->changedColumnsList.clear();
            uint32_t _size590;
            ::apache::thrift::protocol::TType _etype593;
            xfer += iprot->readListBegin(_etype593, _size590);
            this->changedColumnsList.resize(_size590);
            uint32_t _i594;
            for (_i594 = 0; _i594 < _size590; ++_i594)
            {
              {
                this->changedColumnsList[_i594].clear();
                uint32_t _size595;
                ::apache::thrift::protocol::TType _etype598;
                xfer += iprot->readListBegin(_etype598, _size595);
                this->changedColumnsList[_i594].resize(_size595);
                uint32_t _i599;
                for (_i599 = 0; _i599 < _size595; ++_i599)
                {
                  xfer += iprot->readI32(this->changedColumnsList[_i594][_i599]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.changedColumnsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->changedRowIndexes.clear();
            uint32_t _size600;
            ::apache::thrift::protocol::TType _etype603;
            xfer += iprot->readListBegin(_etype603, _size600);
            this->changedRowIndexes.resize(_size600);
            uint32_t _i604;
            for (_i604 = 0; _i604 < _size600; ++_i604)
            {
              xfer += iprot->readI32(this->changedRowIndexes[_i604]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.changedRowIndexes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeCursorUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeCursorUpdate_args");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cursorId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->operations.size()));
    std::vector<CursorUpdateOperation::type> ::const_iterator _iter605;
    for (_iter605 = this->operations.begin(); _iter605 != this->operations.end(); ++_iter605)
    {
      xfer += oprot->writeI32((int32_t)(*_iter605));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedRows", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->changedRows.size()));
    std::vector<Row> ::const_iterator _iter606;
    for (_iter606 = this->changedRows.begin(); _iter606 != this->changedRows.end(); ++_iter606)
    {
      xfer += (*_iter606).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedColumnsList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->changedColumnsList.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter607;
    for (_iter607 = this->changedColumnsList.begin(); _iter607 != this->changedColumnsList.end(); ++_iter607)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter607).size()));
        std::vector<int32_t> ::const_iterator _iter608;
        for (_iter608 = (*_iter607).begin(); _iter608 != (*_iter607).end(); ++_iter608)
        {
          xfer += oprot->writeI32((*_iter608));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedRowIndexes", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->changedRowIndexes.size()));
    std::vector<int32_t> ::const_iterator _iter609;
    for (_iter609 = this->changedRowIndexes.begin(); _iter609 != this->changedRowIndexes.end(); ++_iter609)
    {
      xfer += oprot->writeI32((*_iter609));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeCursorUpdate_pargs::~SnappyDataService_executeCursorUpdate_pargs() noexcept {
}


uint32_t SnappyDataService_executeCursorUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeCursorUpdate_pargs");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->cursorId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->operations)).size()));
    std::vector<CursorUpdateOperation::type> ::const_iterator _iter610;
    for (_iter610 = (*(this->operations)).begin(); _iter610 != (*(this->operations)).end(); ++_iter610)
    {
      xfer += oprot->writeI32((int32_t)(*_iter610));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedRows", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->changedRows)).size()));
    std::vector<Row> ::const_iterator _iter611;
    for (_iter611 = (*(this->changedRows)).begin(); _iter611 != (*(this->changedRows)).end(); ++_iter611)
    {
      xfer += (*_iter611).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedColumnsList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->changedColumnsList)).size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter612;
    for (_iter612 = (*(this->changedColumnsList)).begin(); _iter612 != (*(this->changedColumnsList)).end(); ++_iter612)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter612).size()));
        std::vector<int32_t> ::const_iterator _iter613;
        for (_iter613 = (*_iter612).begin(); _iter613 != (*_iter612).end(); ++_iter613)
        {
          xfer += oprot->writeI32((*_iter613));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedRowIndexes", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->changedRowIndexes)).size()));
    std::vector<int32_t> ::const_iterator _iter614;
    for (_iter614 = (*(this->changedRowIndexes)).begin(); _iter614 != (*(this->changedRowIndexes)).end(); ++_iter614)
    {
      xfer += oprot->writeI32((*_iter614));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeCursorUpdate_result::~SnappyDataService_executeCursorUpdate_result() noexcept {
}


uint32_t SnappyDataService_executeCursorUpdate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeCursorUpdate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executeCursorUpdate_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeCursorUpdate_presult::~SnappyDataService_executeCursorUpdate_presult() noexcept {
}


uint32_t SnappyDataService_executeCursorUpdate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getServiceMetaData_args::~SnappyDataService_getServiceMetaData_args() noexcept {
}


uint32_t SnappyDataService_getServiceMetaData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getServiceMetaData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getServiceMetaData_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getServiceMetaData_pargs::~SnappyDataService_getServiceMetaData_pargs() noexcept {
}


uint32_t SnappyDataService_getServiceMetaData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getServiceMetaData_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getServiceMetaData_result::~SnappyDataService_getServiceMetaData_result() noexcept {
}


uint32_t SnappyDataService_getServiceMetaData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getServiceMetaData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getServiceMetaData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getServiceMetaData_presult::~SnappyDataService_getServiceMetaData_presult() noexcept {
}


uint32_t SnappyDataService_getServiceMetaData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getSchemaMetaData_args::~SnappyDataService_getSchemaMetaData_args() noexcept {
}


uint32_t SnappyDataService_getSchemaMetaData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast615;
          xfer += iprot->readI32(ecast615);
          this->schemaCall = (ServiceMetaDataCall::type)ecast615;
          this->__isset.schemaCall = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadataArgs.read(iprot);
          this->__isset.metadataArgs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getSchemaMetaData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getSchemaMetaData_args");

  xfer += oprot->writeFieldBegin("schemaCall", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->schemaCall);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->metadataArgs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getSchemaMetaData_pargs::~SnappyDataService_getSchemaMetaData_pargs() noexcept {
}


uint32_t SnappyDataService_getSchemaMetaData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getSchemaMetaData_pargs");

  xfer += oprot->writeFieldBegin("schemaCall", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)(*(this->schemaCall)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->metadataArgs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getSchemaMetaData_result::~SnappyDataService_getSchemaMetaData_result() noexcept {
}


uint32_t SnappyDataService_getSchemaMetaData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getSchemaMetaData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getSchemaMetaData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getSchemaMetaData_presult::~SnappyDataService_getSchemaMetaData_presult() noexcept {
}


uint32_t SnappyDataService_getSchemaMetaData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getIndexInfo_args::~SnappyDataService_getIndexInfo_args() noexcept {
}


uint32_t SnappyDataService_getIndexInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadataArgs.read(iprot);
          this->__isset.metadataArgs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->unique);
          this->__isset.unique = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->approximate);
          this->__isset.approximate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getIndexInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getIndexInfo_args");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadataArgs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unique", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->unique);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("approximate", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->approximate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getIndexInfo_pargs::~SnappyDataService_getIndexInfo_pargs() noexcept {
}


uint32_t SnappyDataService_getIndexInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getIndexInfo_pargs");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->metadataArgs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unique", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->unique)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("approximate", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->approximate)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getIndexInfo_result::~SnappyDataService_getIndexInfo_result() noexcept {
}


uint32_t SnappyDataService_getIndexInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getIndexInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getIndexInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getIndexInfo_presult::~SnappyDataService_getIndexInfo_presult() noexcept {
}


uint32_t SnappyDataService_getIndexInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getUDTs_args::~SnappyDataService_getUDTs_args() noexcept {
}


uint32_t SnappyDataService_getUDTs_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadataArgs.read(iprot);
          this->__isset.metadataArgs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size616;
            ::apache::thrift::protocol::TType _etype619;
            xfer += iprot->readListBegin(_etype619, _size616);
            this->types.resize(_size616);
            uint32_t _i620;
            for (_i620 = 0; _i620 < _size616; ++_i620)
            {
              int32_t ecast621;
              xfer += iprot->readI32(ecast621);
              this->types[_i620] = (SnappyType::type)ecast621;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getUDTs_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getUDTs_args");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadataArgs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->types.size()));
    std::vector<SnappyType::type> ::const_iterator _iter622;
    for (_iter622 = this->types.begin(); _iter622 != this->types.end(); ++_iter622)
    {
      xfer += oprot->writeI32((int32_t)(*_iter622));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getUDTs_pargs::~SnappyDataService_getUDTs_pargs() noexcept {
}


uint32_t SnappyDataService_getUDTs_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getUDTs_pargs");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->metadataArgs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->types)).size()));
    std::vector<SnappyType::type> ::const_iterator _iter623;
    for (_iter623 = (*(this->types)).begin(); _iter623 != (*(this->types)).end(); ++_iter623)
    {
      xfer += oprot->writeI32((int32_t)(*_iter623));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getUDTs_result::~SnappyDataService_getUDTs_result() noexcept {
}


uint32_t SnappyDataService_getUDTs_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getUDTs_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getUDTs_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getUDTs_presult::~SnappyDataService_getUDTs_presult() noexcept {
}


uint32_t SnappyDataService_getUDTs_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getBestRowIdentifier_args::~SnappyDataService_getBestRowIdentifier_args() noexcept {
}


uint32_t SnappyDataService_getBestRowIdentifier_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadataArgs.read(iprot);
          this->__isset.metadataArgs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scope);
          this->__isset.scope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->nullable);
          this->__isset.nullable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getBestRowIdentifier_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getBestRowIdentifier_args");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadataArgs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->scope);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullable", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->nullable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBestRowIdentifier_pargs::~SnappyDataService_getBestRowIdentifier_pargs() noexcept {
}


uint32_t SnappyDataService_getBestRowIdentifier_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getBestRowIdentifier_pargs");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->metadataArgs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->scope)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullable", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->nullable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBestRowIdentifier_result::~SnappyDataService_getBestRowIdentifier_result() noexcept {
}


uint32_t SnappyDataService_getBestRowIdentifier_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getBestRowIdentifier_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getBestRowIdentifier_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBestRowIdentifier_presult::~SnappyDataService_getBestRowIdentifier_presult() noexcept {
}


uint32_t SnappyDataService_getBestRowIdentifier_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_fetchActiveConnections_args::~SnappyDataService_fetchActiveConnections_args() noexcept {
}


uint32_t SnappyDataService_fetchActiveConnections_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_fetchActiveConnections_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveConnections_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveConnections_pargs::~SnappyDataService_fetchActiveConnections_pargs() noexcept {
}


uint32_t SnappyDataService_fetchActiveConnections_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveConnections_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveConnections_result::~SnappyDataService_fetchActiveConnections_result() noexcept {
}


uint32_t SnappyDataService_fetchActiveConnections_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size624;
            ::apache::thrift::protocol::TType _etype627;
            xfer += iprot->readListBegin(_etype627, _size624);
            this->success.resize(_size624);
            uint32_t _i628;
            for (_i628 = 0; _i628 < _size624; ++_i628)
            {
              xfer += this->success[_i628].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_fetchActiveConnections_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveConnections_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ConnectionProperties> ::const_iterator _iter629;
      for (_iter629 = this->success.begin(); _iter629 != this->success.end(); ++_iter629)
      {
        xfer += (*_iter629).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveConnections_presult::~SnappyDataService_fetchActiveConnections_presult() noexcept {
}


uint32_t SnappyDataService_fetchActiveConnections_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size630;
            ::apache::thrift::protocol::TType _etype633;
            xfer += iprot->readListBegin(_etype633, _size630);
            (*(this->success)).resize(_size630);
            uint32_t _i634;
            for (_i634 = 0; _i634 < _size630; ++_i634)
            {
              xfer += (*(this->success))[_i634].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_fetchActiveStatements_args::~SnappyDataService_fetchActiveStatements_args() noexcept {
}


uint32_t SnappyDataService_fetchActiveStatements_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_fetchActiveStatements_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveStatements_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveStatements_pargs::~SnappyDataService_fetchActiveStatements_pargs() noexcept {
}


uint32_t SnappyDataService_fetchActiveStatements_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveStatements_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveStatements_result::~SnappyDataService_fetchActiveStatements_result() noexcept {
}


uint32_t SnappyDataService_fetchActiveStatements_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size635;
            ::apache::thrift::protocol::TType _ktype636;
            ::apache::thrift::protocol::TType _vtype637;
            xfer += iprot->readMapBegin(_ktype636, _vtype637, _size635);
            uint32_t _i639;
            for (_i639 = 0; _i639 < _size635; ++_i639)
            {
              int32_t _key640;
              xfer += iprot->readI32(_key640);
              std::string& _val641 = this->success[_key640];
              xfer += iprot->readString(_val641);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_fetchActiveStatements_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveStatements_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<int32_t, std::string> ::const_iterator _iter642;
      for (_iter642 = this->success.begin(); _iter642 != this->success.end(); ++_iter642)
      {
        xfer += oprot->writeI32(_iter642->first);
        xfer += oprot->writeString(_iter642->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveStatements_presult::~SnappyDataService_fetchActiveStatements_presult() noexcept {
}


uint32_t SnappyDataService_fetchActiveStatements_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size643;
            ::apache::thrift::protocol::TType _ktype644;
            ::apache::thrift::protocol::TType _vtype645;
            xfer += iprot->readMapBegin(_ktype644, _vtype645, _size643);
            uint32_t _i647;
            for (_i647 = 0; _i647 < _size643; ++_i647)
            {
              int32_t _key648;
              xfer += iprot->readI32(_key648);
              std::string& _val649 = (*(this->success))[_key648];
              xfer += iprot->readString(_val649);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_cancelStatement_args::~SnappyDataService_cancelStatement_args() noexcept {
}


uint32_t SnappyDataService_cancelStatement_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_cancelStatement_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_cancelStatement_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_cancelStatement_pargs::~SnappyDataService_cancelStatement_pargs() noexcept {
}


uint32_t SnappyDataService_cancelStatement_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_cancelStatement_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_cancelStatement_result::~SnappyDataService_cancelStatement_result() noexcept {
}


uint32_t SnappyDataService_cancelStatement_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_cancelStatement_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_cancelStatement_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_cancelStatement_presult::~SnappyDataService_cancelStatement_presult() noexcept {
}


uint32_t SnappyDataService_cancelStatement_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_closeResultSet_args::~SnappyDataService_closeResultSet_args() noexcept {
}


uint32_t SnappyDataService_closeResultSet_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cursorId);
          this->__isset.cursorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_closeResultSet_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeResultSet_args");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cursorId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeResultSet_pargs::~SnappyDataService_closeResultSet_pargs() noexcept {
}


uint32_t SnappyDataService_closeResultSet_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeResultSet_pargs");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->cursorId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeResultSet_result::~SnappyDataService_closeResultSet_result() noexcept {
}


uint32_t SnappyDataService_closeResultSet_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_closeResultSet_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_closeResultSet_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeResultSet_presult::~SnappyDataService_closeResultSet_presult() noexcept {
}


uint32_t SnappyDataService_closeResultSet_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_closeStatement_args::~SnappyDataService_closeStatement_args() noexcept {
}


uint32_t SnappyDataService_closeStatement_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_closeStatement_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeStatement_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeStatement_pargs::~SnappyDataService_closeStatement_pargs() noexcept {
}


uint32_t SnappyDataService_closeStatement_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeStatement_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeStatement_result::~SnappyDataService_closeStatement_result() noexcept {
}


uint32_t SnappyDataService_closeStatement_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_closeStatement_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_closeStatement_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeStatement_presult::~SnappyDataService_closeStatement_presult() noexcept {
}


uint32_t SnappyDataService_closeStatement_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_closeConnection_args::~SnappyDataService_closeConnection_args() noexcept {
}


uint32_t SnappyDataService_closeConnection_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_closeConnection_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeConnection_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeConnection_pargs::~SnappyDataService_closeConnection_pargs() noexcept {
}


uint32_t SnappyDataService_closeConnection_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeConnection_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_bulkClose_args::~SnappyDataService_bulkClose_args() noexcept {
}


uint32_t SnappyDataService_bulkClose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entities.clear();
            uint32_t _size650;
            ::apache::thrift::protocol::TType _etype653;
            xfer += iprot->readListBegin(_etype653, _size650);
            this->entities.resize(_size650);
            uint32_t _i654;
            for (_i654 = 0; _i654 < _size650; ++_i654)
            {
              xfer += this->entities[_i654].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.entities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_bulkClose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_bulkClose_args");

  xfer += oprot->writeFieldBegin("entities", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->entities.size()));
    std::vector<EntityId> ::const_iterator _iter655;
    for (_iter655 = this->entities.begin(); _iter655 != this->entities.end(); ++_iter655)
    {
      xfer += (*_iter655).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_bulkClose_pargs::~SnappyDataService_bulkClose_pargs() noexcept {
}


uint32_t SnappyDataService_bulkClose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_bulkClose_pargs");

  xfer += oprot->writeFieldBegin("entities", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->entities)).size()));
    std::vector<EntityId> ::const_iterator _iter656;
    for (_iter656 = (*(this->entities)).begin(); _iter656 != (*(this->entities)).end(); ++_iter656)
    {
      xfer += (*_iter656).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void SnappyDataServiceClient::getPreferredServer(HostAddress& _return, const std::set<ServerType::type> & serverTypes, const std::set<std::string> & serverGroups, const std::set<HostAddress> & failedServers)
{
  send_getPreferredServer(serverTypes, serverGroups, failedServers);
  recv_getPreferredServer(_return);
}

void SnappyDataServiceClient::send_getPreferredServer(const std::set<ServerType::type> & serverTypes, const std::set<std::string> & serverGroups, const std::set<HostAddress> & failedServers)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getPreferredServer", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getPreferredServer_pargs args;
  args.serverTypes = &serverTypes;
  args.serverGroups = &serverGroups;
  args.failedServers = &failedServers;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getPreferredServer(HostAddress& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getPreferredServer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getPreferredServer_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getPreferredServer failed: unknown result");
}

void SnappyDataServiceClient::getAllServersWithPreferredServer(std::vector<HostAddress> & _return, const std::set<ServerType::type> & serverTypes, const std::set<std::string> & serverGroups, const std::set<HostAddress> & failedServers)
{
  send_getAllServersWithPreferredServer(serverTypes, serverGroups, failedServers);
  recv_getAllServersWithPreferredServer(_return);
}

void SnappyDataServiceClient::send_getAllServersWithPreferredServer(const std::set<ServerType::type> & serverTypes, const std::set<std::string> & serverGroups, const std::set<HostAddress> & failedServers)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getAllServersWithPreferredServer", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getAllServersWithPreferredServer_pargs args;
  args.serverTypes = &serverTypes;
  args.serverGroups = &serverGroups;
  args.failedServers = &failedServers;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getAllServersWithPreferredServer(std::vector<HostAddress> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getAllServersWithPreferredServer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getAllServersWithPreferredServer_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAllServersWithPreferredServer failed: unknown result");
}

void SnappyDataServiceClient::openConnection(ConnectionProperties& _return, const OpenConnectionArgs& arguments)
{
  send_openConnection(arguments);
  recv_openConnection(_return);
}

void SnappyDataServiceClient::send_openConnection(const OpenConnectionArgs& arguments)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("openConnection", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_openConnection_pargs args;
  args.arguments = &arguments;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_openConnection(ConnectionProperties& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("openConnection") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_openConnection_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "openConnection failed: unknown result");
}

void SnappyDataServiceClient::execute(StatementResult& _return, const int32_t connId, const std::string& sql, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  send_execute(connId, sql, outputParams, attrs, token);
  recv_execute(_return);
}

void SnappyDataServiceClient::send_execute(const int32_t connId, const std::string& sql, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("execute", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_execute_pargs args;
  args.connId = &connId;
  args.sql = &sql;
  args.outputParams = &outputParams;
  args.attrs = &attrs;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_execute(StatementResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("execute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_execute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "execute failed: unknown result");
}

void SnappyDataServiceClient::executeUpdate(UpdateResult& _return, const int32_t connId, const std::vector<std::string> & sqls, const StatementAttrs& attrs, const std::string& token)
{
  send_executeUpdate(connId, sqls, attrs, token);
  recv_executeUpdate(_return);
}

void SnappyDataServiceClient::send_executeUpdate(const int32_t connId, const std::vector<std::string> & sqls, const StatementAttrs& attrs, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executeUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executeUpdate_pargs args;
  args.connId = &connId;
  args.sqls = &sqls;
  args.attrs = &attrs;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executeUpdate(UpdateResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executeUpdate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executeUpdate_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executeUpdate failed: unknown result");
}

void SnappyDataServiceClient::executeQuery(RowSet& _return, const int32_t connId, const std::string& sql, const StatementAttrs& attrs, const std::string& token)
{
  send_executeQuery(connId, sql, attrs, token);
  recv_executeQuery(_return);
}

void SnappyDataServiceClient::send_executeQuery(const int32_t connId, const std::string& sql, const StatementAttrs& attrs, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executeQuery", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executeQuery_pargs args;
  args.connId = &connId;
  args.sql = &sql;
  args.attrs = &attrs;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executeQuery(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executeQuery") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executeQuery_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executeQuery failed: unknown result");
}

void SnappyDataServiceClient::prepareStatement(PrepareResult& _return, const int32_t connId, const std::string& sql, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  send_prepareStatement(connId, sql, outputParams, attrs, token);
  recv_prepareStatement(_return);
}

void SnappyDataServiceClient::send_prepareStatement(const int32_t connId, const std::string& sql, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("prepareStatement", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_prepareStatement_pargs args;
  args.connId = &connId;
  args.sql = &sql;
  args.outputParams = &outputParams;
  args.attrs = &attrs;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_prepareStatement(PrepareResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("prepareStatement") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_prepareStatement_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "prepareStatement failed: unknown result");
}

void SnappyDataServiceClient::executePrepared(StatementResult& _return, const int32_t stmtId, const Row& params, const std::map<int32_t, OutputParameter> & outputParams, const std::string& token)
{
  send_executePrepared(stmtId, params, outputParams, token);
  recv_executePrepared(_return);
}

void SnappyDataServiceClient::send_executePrepared(const int32_t stmtId, const Row& params, const std::map<int32_t, OutputParameter> & outputParams, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executePrepared", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executePrepared_pargs args;
  args.stmtId = &stmtId;
  args.params = &params;
  args.outputParams = &outputParams;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executePrepared(StatementResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executePrepared") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executePrepared_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executePrepared failed: unknown result");
}

void SnappyDataServiceClient::executePreparedUpdate(UpdateResult& _return, const int32_t stmtId, const Row& params, const std::string& token)
{
  send_executePreparedUpdate(stmtId, params, token);
  recv_executePreparedUpdate(_return);
}

void SnappyDataServiceClient::send_executePreparedUpdate(const int32_t stmtId, const Row& params, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executePreparedUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executePreparedUpdate_pargs args;
  args.stmtId = &stmtId;
  args.params = &params;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executePreparedUpdate(UpdateResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executePreparedUpdate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executePreparedUpdate_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executePreparedUpdate failed: unknown result");
}

void SnappyDataServiceClient::executePreparedQuery(RowSet& _return, const int32_t stmtId, const Row& params, const std::string& token)
{
  send_executePreparedQuery(stmtId, params, token);
  recv_executePreparedQuery(_return);
}

void SnappyDataServiceClient::send_executePreparedQuery(const int32_t stmtId, const Row& params, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executePreparedQuery", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executePreparedQuery_pargs args;
  args.stmtId = &stmtId;
  args.params = &params;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executePreparedQuery(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executePreparedQuery") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executePreparedQuery_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executePreparedQuery failed: unknown result");
}

void SnappyDataServiceClient::executePreparedBatch(UpdateResult& _return, const int32_t stmtId, const std::vector<Row> & paramsBatch, const std::string& token)
{
  send_executePreparedBatch(stmtId, paramsBatch, token);
  recv_executePreparedBatch(_return);
}

void SnappyDataServiceClient::send_executePreparedBatch(const int32_t stmtId, const std::vector<Row> & paramsBatch, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executePreparedBatch", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executePreparedBatch_pargs args;
  args.stmtId = &stmtId;
  args.paramsBatch = &paramsBatch;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executePreparedBatch(UpdateResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executePreparedBatch") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executePreparedBatch_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executePreparedBatch failed: unknown result");
}

void SnappyDataServiceClient::prepareAndExecute(StatementResult& _return, const int32_t connId, const std::string& sql, const std::vector<Row> & paramsBatch, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  send_prepareAndExecute(connId, sql, paramsBatch, outputParams, attrs, token);
  recv_prepareAndExecute(_return);
}

void SnappyDataServiceClient::send_prepareAndExecute(const int32_t connId, const std::string& sql, const std::vector<Row> & paramsBatch, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("prepareAndExecute", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_prepareAndExecute_pargs args;
  args.connId = &connId;
  args.sql = &sql;
  args.paramsBatch = &paramsBatch;
  args.outputParams = &outputParams;
  args.attrs = &attrs;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_prepareAndExecute(StatementResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("prepareAndExecute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_prepareAndExecute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "prepareAndExecute failed: unknown result");
}

void SnappyDataServiceClient::beginTransaction(const int32_t connId, const int8_t isolationLevel, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  send_beginTransaction(connId, isolationLevel, flags, token);
  recv_beginTransaction();
}

void SnappyDataServiceClient::send_beginTransaction(const int32_t connId, const int8_t isolationLevel, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("beginTransaction", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_beginTransaction_pargs args;
  args.connId = &connId;
  args.isolationLevel = &isolationLevel;
  args.flags = &flags;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_beginTransaction()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("beginTransaction") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_beginTransaction_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::setTransactionAttributes(const int32_t connId, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  send_setTransactionAttributes(connId, flags, token);
  recv_setTransactionAttributes();
}

void SnappyDataServiceClient::send_setTransactionAttributes(const int32_t connId, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setTransactionAttributes", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_setTransactionAttributes_pargs args;
  args.connId = &connId;
  args.flags = &flags;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_setTransactionAttributes()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setTransactionAttributes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_setTransactionAttributes_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::getTransactionAttributes(std::map<TransactionAttribute::type, bool> & _return, const int32_t connId, const std::string& token)
{
  send_getTransactionAttributes(connId, token);
  recv_getTransactionAttributes(_return);
}

void SnappyDataServiceClient::send_getTransactionAttributes(const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getTransactionAttributes", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getTransactionAttributes_pargs args;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getTransactionAttributes(std::map<TransactionAttribute::type, bool> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getTransactionAttributes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getTransactionAttributes_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTransactionAttributes failed: unknown result");
}

void SnappyDataServiceClient::commitTransaction(const int32_t connId, const bool startNewTransaction, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  send_commitTransaction(connId, startNewTransaction, flags, token);
  recv_commitTransaction();
}

void SnappyDataServiceClient::send_commitTransaction(const int32_t connId, const bool startNewTransaction, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commitTransaction", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_commitTransaction_pargs args;
  args.connId = &connId;
  args.startNewTransaction = &startNewTransaction;
  args.flags = &flags;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_commitTransaction()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commitTransaction") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_commitTransaction_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::rollbackTransaction(const int32_t connId, const bool startNewTransaction, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  send_rollbackTransaction(connId, startNewTransaction, flags, token);
  recv_rollbackTransaction();
}

void SnappyDataServiceClient::send_rollbackTransaction(const int32_t connId, const bool startNewTransaction, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("rollbackTransaction", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_rollbackTransaction_pargs args;
  args.connId = &connId;
  args.startNewTransaction = &startNewTransaction;
  args.flags = &flags;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_rollbackTransaction()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("rollbackTransaction") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_rollbackTransaction_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

bool SnappyDataServiceClient::prepareCommitTransaction(const int32_t connId, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  send_prepareCommitTransaction(connId, flags, token);
  return recv_prepareCommitTransaction();
}

void SnappyDataServiceClient::send_prepareCommitTransaction(const int32_t connId, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("prepareCommitTransaction", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_prepareCommitTransaction_pargs args;
  args.connId = &connId;
  args.flags = &flags;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool SnappyDataServiceClient::recv_prepareCommitTransaction()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("prepareCommitTransaction") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  SnappyDataService_prepareCommitTransaction_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "prepareCommitTransaction failed: unknown result");
}

void SnappyDataServiceClient::getNextResultSet(RowSet& _return, const int32_t cursorId, const int8_t otherResultSetBehaviour, const std::string& token)
{
  send_getNextResultSet(cursorId, otherResultSetBehaviour, token);
  recv_getNextResultSet(_return);
}

void SnappyDataServiceClient::send_getNextResultSet(const int32_t cursorId, const int8_t otherResultSetBehaviour, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNextResultSet", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getNextResultSet_pargs args;
  args.cursorId = &cursorId;
  args.otherResultSetBehaviour = &otherResultSetBehaviour;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getNextResultSet(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNextResultSet") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getNextResultSet_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNextResultSet failed: unknown result");
}

void SnappyDataServiceClient::getBlobChunk(BlobChunk& _return, const int32_t connId, const int32_t lobId, const int64_t offset, const int32_t size, const bool freeLobAtEnd, const std::string& token)
{
  send_getBlobChunk(connId, lobId, offset, size, freeLobAtEnd, token);
  recv_getBlobChunk(_return);
}

void SnappyDataServiceClient::send_getBlobChunk(const int32_t connId, const int32_t lobId, const int64_t offset, const int32_t size, const bool freeLobAtEnd, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getBlobChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getBlobChunk_pargs args;
  args.connId = &connId;
  args.lobId = &lobId;
  args.offset = &offset;
  args.size = &size;
  args.freeLobAtEnd = &freeLobAtEnd;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getBlobChunk(BlobChunk& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getBlobChunk") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getBlobChunk_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getBlobChunk failed: unknown result");
}

void SnappyDataServiceClient::getClobChunk(ClobChunk& _return, const int32_t connId, const int32_t lobId, const int64_t offset, const int32_t size, const bool freeLobAtEnd, const std::string& token)
{
  send_getClobChunk(connId, lobId, offset, size, freeLobAtEnd, token);
  recv_getClobChunk(_return);
}

void SnappyDataServiceClient::send_getClobChunk(const int32_t connId, const int32_t lobId, const int64_t offset, const int32_t size, const bool freeLobAtEnd, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getClobChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getClobChunk_pargs args;
  args.connId = &connId;
  args.lobId = &lobId;
  args.offset = &offset;
  args.size = &size;
  args.freeLobAtEnd = &freeLobAtEnd;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getClobChunk(ClobChunk& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getClobChunk") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getClobChunk_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getClobChunk failed: unknown result");
}

int32_t SnappyDataServiceClient::sendBlobChunk(const BlobChunk& chunk, const int32_t connId, const std::string& token)
{
  send_sendBlobChunk(chunk, connId, token);
  return recv_sendBlobChunk();
}

void SnappyDataServiceClient::send_sendBlobChunk(const BlobChunk& chunk, const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sendBlobChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_sendBlobChunk_pargs args;
  args.chunk = &chunk;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t SnappyDataServiceClient::recv_sendBlobChunk()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sendBlobChunk") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  SnappyDataService_sendBlobChunk_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sendBlobChunk failed: unknown result");
}

int32_t SnappyDataServiceClient::sendClobChunk(const ClobChunk& chunk, const int32_t connId, const std::string& token)
{
  send_sendClobChunk(chunk, connId, token);
  return recv_sendClobChunk();
}

void SnappyDataServiceClient::send_sendClobChunk(const ClobChunk& chunk, const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sendClobChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_sendClobChunk_pargs args;
  args.chunk = &chunk;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t SnappyDataServiceClient::recv_sendClobChunk()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sendClobChunk") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  SnappyDataService_sendClobChunk_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sendClobChunk failed: unknown result");
}

void SnappyDataServiceClient::freeLob(const int32_t connId, const int32_t lobId, const std::string& token)
{
  send_freeLob(connId, lobId, token);
  recv_freeLob();
}

void SnappyDataServiceClient::send_freeLob(const int32_t connId, const int32_t lobId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("freeLob", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_freeLob_pargs args;
  args.connId = &connId;
  args.lobId = &lobId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_freeLob()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("freeLob") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_freeLob_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::scrollCursor(RowSet& _return, const int32_t cursorId, const int32_t offset, const bool offsetIsAbsolute, const bool fetchReverse, const int32_t fetchSize, const std::string& token)
{
  send_scrollCursor(cursorId, offset, offsetIsAbsolute, fetchReverse, fetchSize, token);
  recv_scrollCursor(_return);
}

void SnappyDataServiceClient::send_scrollCursor(const int32_t cursorId, const int32_t offset, const bool offsetIsAbsolute, const bool fetchReverse, const int32_t fetchSize, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("scrollCursor", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_scrollCursor_pargs args;
  args.cursorId = &cursorId;
  args.offset = &offset;
  args.offsetIsAbsolute = &offsetIsAbsolute;
  args.fetchReverse = &fetchReverse;
  args.fetchSize = &fetchSize;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_scrollCursor(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("scrollCursor") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_scrollCursor_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "scrollCursor failed: unknown result");
}

void SnappyDataServiceClient::executeCursorUpdate(const int32_t cursorId, const std::vector<CursorUpdateOperation::type> & operations, const std::vector<Row> & changedRows, const std::vector<std::vector<int32_t> > & changedColumnsList, const std::vector<int32_t> & changedRowIndexes, const std::string& token)
{
  send_executeCursorUpdate(cursorId, operations, changedRows, changedColumnsList, changedRowIndexes, token);
  recv_executeCursorUpdate();
}

void SnappyDataServiceClient::send_executeCursorUpdate(const int32_t cursorId, const std::vector<CursorUpdateOperation::type> & operations, const std::vector<Row> & changedRows, const std::vector<std::vector<int32_t> > & changedColumnsList, const std::vector<int32_t> & changedRowIndexes, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executeCursorUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executeCursorUpdate_pargs args;
  args.cursorId = &cursorId;
  args.operations = &operations;
  args.changedRows = &changedRows;
  args.changedColumnsList = &changedColumnsList;
  args.changedRowIndexes = &changedRowIndexes;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executeCursorUpdate()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executeCursorUpdate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executeCursorUpdate_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::getServiceMetaData(ServiceMetaData& _return, const int32_t connId, const std::string& token)
{
  send_getServiceMetaData(connId, token);
  recv_getServiceMetaData(_return);
}

void SnappyDataServiceClient::send_getServiceMetaData(const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getServiceMetaData", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getServiceMetaData_pargs args;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getServiceMetaData(ServiceMetaData& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getServiceMetaData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getServiceMetaData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getServiceMetaData failed: unknown result");
}

void SnappyDataServiceClient::getSchemaMetaData(RowSet& _return, const ServiceMetaDataCall::type schemaCall, const ServiceMetaDataArgs& metadataArgs)
{
  send_getSchemaMetaData(schemaCall, metadataArgs);
  recv_getSchemaMetaData(_return);
}

void SnappyDataServiceClient::send_getSchemaMetaData(const ServiceMetaDataCall::type schemaCall, const ServiceMetaDataArgs& metadataArgs)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getSchemaMetaData", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getSchemaMetaData_pargs args;
  args.schemaCall = &schemaCall;
  args.metadataArgs = &metadataArgs;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getSchemaMetaData(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getSchemaMetaData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getSchemaMetaData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSchemaMetaData failed: unknown result");
}

void SnappyDataServiceClient::getIndexInfo(RowSet& _return, const ServiceMetaDataArgs& metadataArgs, const bool unique, const bool approximate)
{
  send_getIndexInfo(metadataArgs, unique, approximate);
  recv_getIndexInfo(_return);
}

void SnappyDataServiceClient::send_getIndexInfo(const ServiceMetaDataArgs& metadataArgs, const bool unique, const bool approximate)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getIndexInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getIndexInfo_pargs args;
  args.metadataArgs = &metadataArgs;
  args.unique = &unique;
  args.approximate = &approximate;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getIndexInfo(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getIndexInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getIndexInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getIndexInfo failed: unknown result");
}

void SnappyDataServiceClient::getUDTs(RowSet& _return, const ServiceMetaDataArgs& metadataArgs, const std::vector<SnappyType::type> & types)
{
  send_getUDTs(metadataArgs, types);
  recv_getUDTs(_return);
}

void SnappyDataServiceClient::send_getUDTs(const ServiceMetaDataArgs& metadataArgs, const std::vector<SnappyType::type> & types)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getUDTs", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getUDTs_pargs args;
  args.metadataArgs = &metadataArgs;
  args.types = &types;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getUDTs(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getUDTs") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getUDTs_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getUDTs failed: unknown result");
}

void SnappyDataServiceClient::getBestRowIdentifier(RowSet& _return, const ServiceMetaDataArgs& metadataArgs, const int32_t scope, const bool nullable)
{
  send_getBestRowIdentifier(metadataArgs, scope, nullable);
  recv_getBestRowIdentifier(_return);
}

void SnappyDataServiceClient::send_getBestRowIdentifier(const ServiceMetaDataArgs& metadataArgs, const int32_t scope, const bool nullable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getBestRowIdentifier", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getBestRowIdentifier_pargs args;
  args.metadataArgs = &metadataArgs;
  args.scope = &scope;
  args.nullable = &nullable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getBestRowIdentifier(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getBestRowIdentifier") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getBestRowIdentifier_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getBestRowIdentifier failed: unknown result");
}

void SnappyDataServiceClient::fetchActiveConnections(std::vector<ConnectionProperties> & _return, const int32_t connId, const std::string& token)
{
  send_fetchActiveConnections(connId, token);
  recv_fetchActiveConnections(_return);
}

void SnappyDataServiceClient::send_fetchActiveConnections(const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("fetchActiveConnections", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_fetchActiveConnections_pargs args;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_fetchActiveConnections(std::vector<ConnectionProperties> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("fetchActiveConnections") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_fetchActiveConnections_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "fetchActiveConnections failed: unknown result");
}

void SnappyDataServiceClient::fetchActiveStatements(std::map<int32_t, std::string> & _return, const int32_t connId, const std::string& token)
{
  send_fetchActiveStatements(connId, token);
  recv_fetchActiveStatements(_return);
}

void SnappyDataServiceClient::send_fetchActiveStatements(const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("fetchActiveStatements", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_fetchActiveStatements_pargs args;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_fetchActiveStatements(std::map<int32_t, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("fetchActiveStatements") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_fetchActiveStatements_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "fetchActiveStatements failed: unknown result");
}

void SnappyDataServiceClient::cancelStatement(const int32_t stmtId, const std::string& token)
{
  send_cancelStatement(stmtId, token);
  recv_cancelStatement();
}

void SnappyDataServiceClient::send_cancelStatement(const int32_t stmtId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("cancelStatement", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_cancelStatement_pargs args;
  args.stmtId = &stmtId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_cancelStatement()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("cancelStatement") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_cancelStatement_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::closeResultSet(const int32_t cursorId, const std::string& token)
{
  send_closeResultSet(cursorId, token);
  recv_closeResultSet();
}

void SnappyDataServiceClient::send_closeResultSet(const int32_t cursorId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeResultSet", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_closeResultSet_pargs args;
  args.cursorId = &cursorId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_closeResultSet()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("closeResultSet") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_closeResultSet_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::closeStatement(const int32_t stmtId, const std::string& token)
{
  send_closeStatement(stmtId, token);
  recv_closeStatement();
}

void SnappyDataServiceClient::send_closeStatement(const int32_t stmtId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeStatement", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_closeStatement_pargs args;
  args.stmtId = &stmtId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_closeStatement()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("closeStatement") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_closeStatement_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::closeConnection(const int32_t connId, const std::string& token)
{
  send_closeConnection(connId, token);
}

void SnappyDataServiceClient::send_closeConnection(const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeConnection", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  SnappyDataService_closeConnection_pargs args;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::bulkClose(const std::vector<EntityId> & entities)
{
  send_bulkClose(entities);
}

void SnappyDataServiceClient::send_bulkClose(const std::vector<EntityId> & entities)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bulkClose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  SnappyDataService_bulkClose_pargs args;
  args.entities = &entities;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool SnappyDataServiceProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void SnappyDataServiceProcessor::process_getPreferredServer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getPreferredServer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getPreferredServer");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getPreferredServer");
  }

  SnappyDataService_getPreferredServer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getPreferredServer", bytes);
  }

  SnappyDataService_getPreferredServer_result result;
  try {
    iface_->getPreferredServer(result.success, args.serverTypes, args.serverGroups, args.failedServers);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getPreferredServer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getPreferredServer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getPreferredServer");
  }

  oprot->writeMessageBegin("getPreferredServer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getPreferredServer", bytes);
  }
}

void SnappyDataServiceProcessor::process_getAllServersWithPreferredServer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getAllServersWithPreferredServer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getAllServersWithPreferredServer");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getAllServersWithPreferredServer");
  }

  SnappyDataService_getAllServersWithPreferredServer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getAllServersWithPreferredServer", bytes);
  }

  SnappyDataService_getAllServersWithPreferredServer_result result;
  try {
    iface_->getAllServersWithPreferredServer(result.success, args.serverTypes, args.serverGroups, args.failedServers);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getAllServersWithPreferredServer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getAllServersWithPreferredServer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getAllServersWithPreferredServer");
  }

  oprot->writeMessageBegin("getAllServersWithPreferredServer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getAllServersWithPreferredServer", bytes);
  }
}

void SnappyDataServiceProcessor::process_openConnection(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.openConnection", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.openConnection");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.openConnection");
  }

  SnappyDataService_openConnection_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.openConnection", bytes);
  }

  SnappyDataService_openConnection_result result;
  try {
    iface_->openConnection(result.success, args.arguments);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.openConnection");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("openConnection", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.openConnection");
  }

  oprot->writeMessageBegin("openConnection", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.openConnection", bytes);
  }
}

void SnappyDataServiceProcessor::process_execute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.execute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.execute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.execute");
  }

  SnappyDataService_execute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.execute", bytes);
  }

  SnappyDataService_execute_result result;
  try {
    iface_->execute(result.success, args.connId, args.sql, args.outputParams, args.attrs, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.execute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("execute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.execute");
  }

  oprot->writeMessageBegin("execute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.execute", bytes);
  }
}

void SnappyDataServiceProcessor::process_executeUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executeUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executeUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executeUpdate");
  }

  SnappyDataService_executeUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executeUpdate", bytes);
  }

  SnappyDataService_executeUpdate_result result;
  try {
    iface_->executeUpdate(result.success, args.connId, args.sqls, args.attrs, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executeUpdate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executeUpdate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executeUpdate");
  }

  oprot->writeMessageBegin("executeUpdate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executeUpdate", bytes);
  }
}

void SnappyDataServiceProcessor::process_executeQuery(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executeQuery", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executeQuery");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executeQuery");
  }

  SnappyDataService_executeQuery_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executeQuery", bytes);
  }

  SnappyDataService_executeQuery_result result;
  try {
    iface_->executeQuery(result.success, args.connId, args.sql, args.attrs, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executeQuery");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executeQuery", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executeQuery");
  }

  oprot->writeMessageBegin("executeQuery", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executeQuery", bytes);
  }
}

void SnappyDataServiceProcessor::process_prepareStatement(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.prepareStatement", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.prepareStatement");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.prepareStatement");
  }

  SnappyDataService_prepareStatement_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.prepareStatement", bytes);
  }

  SnappyDataService_prepareStatement_result result;
  try {
    iface_->prepareStatement(result.success, args.connId, args.sql, args.outputParams, args.attrs, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.prepareStatement");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("prepareStatement", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.prepareStatement");
  }

  oprot->writeMessageBegin("prepareStatement", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.prepareStatement", bytes);
  }
}

void SnappyDataServiceProcessor::process_executePrepared(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executePrepared", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executePrepared");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executePrepared");
  }

  SnappyDataService_executePrepared_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executePrepared", bytes);
  }

  SnappyDataService_executePrepared_result result;
  try {
    iface_->executePrepared(result.success, args.stmtId, args.params, args.outputParams, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executePrepared");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executePrepared", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executePrepared");
  }

  oprot->writeMessageBegin("executePrepared", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executePrepared", bytes);
  }
}

void SnappyDataServiceProcessor::process_executePreparedUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executePreparedUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executePreparedUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executePreparedUpdate");
  }

  SnappyDataService_executePreparedUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executePreparedUpdate", bytes);
  }

  SnappyDataService_executePreparedUpdate_result result;
  try {
    iface_->executePreparedUpdate(result.success, args.stmtId, args.params, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executePreparedUpdate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executePreparedUpdate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executePreparedUpdate");
  }

  oprot->writeMessageBegin("executePreparedUpdate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executePreparedUpdate", bytes);
  }
}

void SnappyDataServiceProcessor::process_executePreparedQuery(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executePreparedQuery", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executePreparedQuery");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executePreparedQuery");
  }

  SnappyDataService_executePreparedQuery_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executePreparedQuery", bytes);
  }

  SnappyDataService_executePreparedQuery_result result;
  try {
    iface_->executePreparedQuery(result.success, args.stmtId, args.params, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executePreparedQuery");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executePreparedQuery", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executePreparedQuery");
  }

  oprot->writeMessageBegin("executePreparedQuery", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executePreparedQuery", bytes);
  }
}

void SnappyDataServiceProcessor::process_executePreparedBatch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executePreparedBatch", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executePreparedBatch");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executePreparedBatch");
  }

  SnappyDataService_executePreparedBatch_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executePreparedBatch", bytes);
  }

  SnappyDataService_executePreparedBatch_result result;
  try {
    iface_->executePreparedBatch(result.success, args.stmtId, args.paramsBatch, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executePreparedBatch");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executePreparedBatch", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executePreparedBatch");
  }

  oprot->writeMessageBegin("executePreparedBatch", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executePreparedBatch", bytes);
  }
}

void SnappyDataServiceProcessor::process_prepareAndExecute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.prepareAndExecute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.prepareAndExecute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.prepareAndExecute");
  }

  SnappyDataService_prepareAndExecute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.prepareAndExecute", bytes);
  }

  SnappyDataService_prepareAndExecute_result result;
  try {
    iface_->prepareAndExecute(result.success, args.connId, args.sql, args.paramsBatch, args.outputParams, args.attrs, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.prepareAndExecute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("prepareAndExecute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.prepareAndExecute");
  }

  oprot->writeMessageBegin("prepareAndExecute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.prepareAndExecute", bytes);
  }
}

void SnappyDataServiceProcessor::process_beginTransaction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.beginTransaction", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.beginTransaction");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.beginTransaction");
  }

  SnappyDataService_beginTransaction_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.beginTransaction", bytes);
  }

  SnappyDataService_beginTransaction_result result;
  try {
    iface_->beginTransaction(args.connId, args.isolationLevel, args.flags, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.beginTransaction");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("beginTransaction", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.beginTransaction");
  }

  oprot->writeMessageBegin("beginTransaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.beginTransaction", bytes);
  }
}

void SnappyDataServiceProcessor::process_setTransactionAttributes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.setTransactionAttributes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.setTransactionAttributes");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.setTransactionAttributes");
  }

  SnappyDataService_setTransactionAttributes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.setTransactionAttributes", bytes);
  }

  SnappyDataService_setTransactionAttributes_result result;
  try {
    iface_->setTransactionAttributes(args.connId, args.flags, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.setTransactionAttributes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setTransactionAttributes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.setTransactionAttributes");
  }

  oprot->writeMessageBegin("setTransactionAttributes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.setTransactionAttributes", bytes);
  }
}

void SnappyDataServiceProcessor::process_getTransactionAttributes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getTransactionAttributes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getTransactionAttributes");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getTransactionAttributes");
  }

  SnappyDataService_getTransactionAttributes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getTransactionAttributes", bytes);
  }

  SnappyDataService_getTransactionAttributes_result result;
  try {
    iface_->getTransactionAttributes(result.success, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getTransactionAttributes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getTransactionAttributes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getTransactionAttributes");
  }

  oprot->writeMessageBegin("getTransactionAttributes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getTransactionAttributes", bytes);
  }
}

void SnappyDataServiceProcessor::process_commitTransaction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.commitTransaction", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.commitTransaction");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.commitTransaction");
  }

  SnappyDataService_commitTransaction_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.commitTransaction", bytes);
  }

  SnappyDataService_commitTransaction_result result;
  try {
    iface_->commitTransaction(args.connId, args.startNewTransaction, args.flags, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.commitTransaction");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commitTransaction", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.commitTransaction");
  }

  oprot->writeMessageBegin("commitTransaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.commitTransaction", bytes);
  }
}

void SnappyDataServiceProcessor::process_rollbackTransaction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.rollbackTransaction", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.rollbackTransaction");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.rollbackTransaction");
  }

  SnappyDataService_rollbackTransaction_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.rollbackTransaction", bytes);
  }

  SnappyDataService_rollbackTransaction_result result;
  try {
    iface_->rollbackTransaction(args.connId, args.startNewTransaction, args.flags, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.rollbackTransaction");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("rollbackTransaction", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.rollbackTransaction");
  }

  oprot->writeMessageBegin("rollbackTransaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.rollbackTransaction", bytes);
  }
}

void SnappyDataServiceProcessor::process_prepareCommitTransaction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.prepareCommitTransaction", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.prepareCommitTransaction");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.prepareCommitTransaction");
  }

  SnappyDataService_prepareCommitTransaction_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.prepareCommitTransaction", bytes);
  }

  SnappyDataService_prepareCommitTransaction_result result;
  try {
    result.success = iface_->prepareCommitTransaction(args.connId, args.flags, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.prepareCommitTransaction");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("prepareCommitTransaction", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.prepareCommitTransaction");
  }

  oprot->writeMessageBegin("prepareCommitTransaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.prepareCommitTransaction", bytes);
  }
}

void SnappyDataServiceProcessor::process_getNextResultSet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getNextResultSet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getNextResultSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getNextResultSet");
  }

  SnappyDataService_getNextResultSet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getNextResultSet", bytes);
  }

  SnappyDataService_getNextResultSet_result result;
  try {
    iface_->getNextResultSet(result.success, args.cursorId, args.otherResultSetBehaviour, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getNextResultSet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNextResultSet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getNextResultSet");
  }

  oprot->writeMessageBegin("getNextResultSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getNextResultSet", bytes);
  }
}

void SnappyDataServiceProcessor::process_getBlobChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getBlobChunk", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getBlobChunk");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getBlobChunk");
  }

  SnappyDataService_getBlobChunk_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getBlobChunk", bytes);
  }

  SnappyDataService_getBlobChunk_result result;
  try {
    iface_->getBlobChunk(result.success, args.connId, args.lobId, args.offset, args.size, args.freeLobAtEnd, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getBlobChunk");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getBlobChunk", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getBlobChunk");
  }

  oprot->writeMessageBegin("getBlobChunk", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getBlobChunk", bytes);
  }
}

void SnappyDataServiceProcessor::process_getClobChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getClobChunk", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getClobChunk");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getClobChunk");
  }

  SnappyDataService_getClobChunk_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getClobChunk", bytes);
  }

  SnappyDataService_getClobChunk_result result;
  try {
    iface_->getClobChunk(result.success, args.connId, args.lobId, args.offset, args.size, args.freeLobAtEnd, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getClobChunk");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getClobChunk", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getClobChunk");
  }

  oprot->writeMessageBegin("getClobChunk", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getClobChunk", bytes);
  }
}

void SnappyDataServiceProcessor::process_sendBlobChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.sendBlobChunk", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.sendBlobChunk");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.sendBlobChunk");
  }

  SnappyDataService_sendBlobChunk_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.sendBlobChunk", bytes);
  }

  SnappyDataService_sendBlobChunk_result result;
  try {
    result.success = iface_->sendBlobChunk(args.chunk, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.sendBlobChunk");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sendBlobChunk", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.sendBlobChunk");
  }

  oprot->writeMessageBegin("sendBlobChunk", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.sendBlobChunk", bytes);
  }
}

void SnappyDataServiceProcessor::process_sendClobChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.sendClobChunk", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.sendClobChunk");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.sendClobChunk");
  }

  SnappyDataService_sendClobChunk_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.sendClobChunk", bytes);
  }

  SnappyDataService_sendClobChunk_result result;
  try {
    result.success = iface_->sendClobChunk(args.chunk, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.sendClobChunk");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sendClobChunk", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.sendClobChunk");
  }

  oprot->writeMessageBegin("sendClobChunk", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.sendClobChunk", bytes);
  }
}

void SnappyDataServiceProcessor::process_freeLob(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.freeLob", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.freeLob");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.freeLob");
  }

  SnappyDataService_freeLob_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.freeLob", bytes);
  }

  SnappyDataService_freeLob_result result;
  try {
    iface_->freeLob(args.connId, args.lobId, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.freeLob");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("freeLob", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.freeLob");
  }

  oprot->writeMessageBegin("freeLob", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.freeLob", bytes);
  }
}

void SnappyDataServiceProcessor::process_scrollCursor(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.scrollCursor", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.scrollCursor");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.scrollCursor");
  }

  SnappyDataService_scrollCursor_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.scrollCursor", bytes);
  }

  SnappyDataService_scrollCursor_result result;
  try {
    iface_->scrollCursor(result.success, args.cursorId, args.offset, args.offsetIsAbsolute, args.fetchReverse, args.fetchSize, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.scrollCursor");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("scrollCursor", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.scrollCursor");
  }

  oprot->writeMessageBegin("scrollCursor", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.scrollCursor", bytes);
  }
}

void SnappyDataServiceProcessor::process_executeCursorUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executeCursorUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executeCursorUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executeCursorUpdate");
  }

  SnappyDataService_executeCursorUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executeCursorUpdate", bytes);
  }

  SnappyDataService_executeCursorUpdate_result result;
  try {
    iface_->executeCursorUpdate(args.cursorId, args.operations, args.changedRows, args.changedColumnsList, args.changedRowIndexes, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executeCursorUpdate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executeCursorUpdate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executeCursorUpdate");
  }

  oprot->writeMessageBegin("executeCursorUpdate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executeCursorUpdate", bytes);
  }
}

void SnappyDataServiceProcessor::process_getServiceMetaData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getServiceMetaData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getServiceMetaData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getServiceMetaData");
  }

  SnappyDataService_getServiceMetaData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getServiceMetaData", bytes);
  }

  SnappyDataService_getServiceMetaData_result result;
  try {
    iface_->getServiceMetaData(result.success, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getServiceMetaData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getServiceMetaData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getServiceMetaData");
  }

  oprot->writeMessageBegin("getServiceMetaData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getServiceMetaData", bytes);
  }
}

void SnappyDataServiceProcessor::process_getSchemaMetaData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getSchemaMetaData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getSchemaMetaData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getSchemaMetaData");
  }

  SnappyDataService_getSchemaMetaData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getSchemaMetaData", bytes);
  }

  SnappyDataService_getSchemaMetaData_result result;
  try {
    iface_->getSchemaMetaData(result.success, args.schemaCall, args.metadataArgs);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getSchemaMetaData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getSchemaMetaData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getSchemaMetaData");
  }

  oprot->writeMessageBegin("getSchemaMetaData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getSchemaMetaData", bytes);
  }
}

void SnappyDataServiceProcessor::process_getIndexInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getIndexInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getIndexInfo");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getIndexInfo");
  }

  SnappyDataService_getIndexInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getIndexInfo", bytes);
  }

  SnappyDataService_getIndexInfo_result result;
  try {
    iface_->getIndexInfo(result.success, args.metadataArgs, args.unique, args.approximate);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getIndexInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getIndexInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getIndexInfo");
  }

  oprot->writeMessageBegin("getIndexInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getIndexInfo", bytes);
  }
}

void SnappyDataServiceProcessor::process_getUDTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getUDTs", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getUDTs");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getUDTs");
  }

  SnappyDataService_getUDTs_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getUDTs", bytes);
  }

  SnappyDataService_getUDTs_result result;
  try {
    iface_->getUDTs(result.success, args.metadataArgs, args.types);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getUDTs");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getUDTs", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getUDTs");
  }

  oprot->writeMessageBegin("getUDTs", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getUDTs", bytes);
  }
}

void SnappyDataServiceProcessor::process_getBestRowIdentifier(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getBestRowIdentifier", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getBestRowIdentifier");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getBestRowIdentifier");
  }

  SnappyDataService_getBestRowIdentifier_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getBestRowIdentifier", bytes);
  }

  SnappyDataService_getBestRowIdentifier_result result;
  try {
    iface_->getBestRowIdentifier(result.success, args.metadataArgs, args.scope, args.nullable);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getBestRowIdentifier");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getBestRowIdentifier", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getBestRowIdentifier");
  }

  oprot->writeMessageBegin("getBestRowIdentifier", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getBestRowIdentifier", bytes);
  }
}

void SnappyDataServiceProcessor::process_fetchActiveConnections(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.fetchActiveConnections", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.fetchActiveConnections");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.fetchActiveConnections");
  }

  SnappyDataService_fetchActiveConnections_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.fetchActiveConnections", bytes);
  }

  SnappyDataService_fetchActiveConnections_result result;
  try {
    iface_->fetchActiveConnections(result.success, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.fetchActiveConnections");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("fetchActiveConnections", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.fetchActiveConnections");
  }

  oprot->writeMessageBegin("fetchActiveConnections", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.fetchActiveConnections", bytes);
  }
}

void SnappyDataServiceProcessor::process_fetchActiveStatements(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.fetchActiveStatements", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.fetchActiveStatements");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.fetchActiveStatements");
  }

  SnappyDataService_fetchActiveStatements_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.fetchActiveStatements", bytes);
  }

  SnappyDataService_fetchActiveStatements_result result;
  try {
    iface_->fetchActiveStatements(result.success, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.fetchActiveStatements");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("fetchActiveStatements", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.fetchActiveStatements");
  }

  oprot->writeMessageBegin("fetchActiveStatements", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.fetchActiveStatements", bytes);
  }
}

void SnappyDataServiceProcessor::process_cancelStatement(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.cancelStatement", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.cancelStatement");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.cancelStatement");
  }

  SnappyDataService_cancelStatement_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.cancelStatement", bytes);
  }

  SnappyDataService_cancelStatement_result result;
  try {
    iface_->cancelStatement(args.stmtId, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.cancelStatement");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("cancelStatement", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.cancelStatement");
  }

  oprot->writeMessageBegin("cancelStatement", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.cancelStatement", bytes);
  }
}

void SnappyDataServiceProcessor::process_closeResultSet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.closeResultSet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.closeResultSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.closeResultSet");
  }

  SnappyDataService_closeResultSet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.closeResultSet", bytes);
  }

  SnappyDataService_closeResultSet_result result;
  try {
    iface_->closeResultSet(args.cursorId, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.closeResultSet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("closeResultSet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.closeResultSet");
  }

  oprot->writeMessageBegin("closeResultSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.closeResultSet", bytes);
  }
}

void SnappyDataServiceProcessor::process_closeStatement(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.closeStatement", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.closeStatement");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.closeStatement");
  }

  SnappyDataService_closeStatement_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.closeStatement", bytes);
  }

  SnappyDataService_closeStatement_result result;
  try {
    iface_->closeStatement(args.stmtId, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.closeStatement");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("closeStatement", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.closeStatement");
  }

  oprot->writeMessageBegin("closeStatement", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.closeStatement", bytes);
  }
}

void SnappyDataServiceProcessor::process_closeConnection(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.closeConnection", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.closeConnection");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.closeConnection");
  }

  SnappyDataService_closeConnection_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.closeConnection", bytes);
  }

  try {
    iface_->closeConnection(args.connId, args.token);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.closeConnection");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "SnappyDataService.closeConnection");
  }

  return;
}

void SnappyDataServiceProcessor::process_bulkClose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.bulkClose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.bulkClose");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.bulkClose");
  }

  SnappyDataService_bulkClose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.bulkClose", bytes);
  }

  try {
    iface_->bulkClose(args.entities);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.bulkClose");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "SnappyDataService.bulkClose");
  }

  return;
}

::boost::shared_ptr< ::apache::thrift::TProcessor > SnappyDataServiceProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< SnappyDataServiceIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< SnappyDataServiceIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new SnappyDataServiceProcessor(handler));
  return processor;
}

}}} // namespace

